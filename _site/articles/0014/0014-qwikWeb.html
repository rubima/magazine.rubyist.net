<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>qwikWeb の仕組み 【第 3 回】 ページの一部分だけ編集できるようにしてみる</title>
  <meta name="description" content="書いた人：えと こういちろう">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/css/theme.css" rel="stylesheet" type="text/css">
  <link href="/css/syntax.css" rel="stylesheet" type="text/css">

  <link rel="canonical" href="http://localhost:4000/articles/0014/0014-qwikWeb.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="http://localhost:4000/feed.xml">
  <link rel="shortcut icon" href="/images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="/articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="/articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="/articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="/articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="/articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="/articles/pretokyorubykaigi11/preTokyoRubyKaigi11.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="/articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="/articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="/articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="/articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="/articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="/articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="/articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="/articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="/articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="/articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="/articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="/articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="/articles/ruby200specialen/Ruby200SpecialEn.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="/articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="/articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="/articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="/articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="/articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="/articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="/articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="/articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="/articles/prerubykaigi2011/preRubyKaigi2011.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="/articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="/articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="/articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="/articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="/articles/prerubykaigi2010/preRubyKaigi2010.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="/articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="/articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="/articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="/articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="/articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="/articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="/articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="/articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="/articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="/articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="/articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="/articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="/articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="/articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="/articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="/articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="/articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="/articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="/articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="/articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="/articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="/articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="/articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="/articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="/articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="/articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="/articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="/articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="/articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="/articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="/articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="/images/rubima_logo_l.png">
                        <h1>qwikWeb の仕組み 【第 3 回】 ページの一部分だけ編集できるようにしてみる</h1>
                        <div class="social-buttons">
                            <a href="http://b.hatena.ne.jp/entry//articles/0014/0014-qwikWeb.html" class="hatena-bookmark-button" data-hatena-bookmark-title="qwikWeb の仕組み 【第 3 回】 ページの一部分だけ編集できるようにしてみる" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<span id="fb-root"></span>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.5";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<span class="fb-like" data-href="/articles/0014/0014-qwikWeb.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></span>
<a href="https://twitter.com/share" class="twitter-share-button" data-url="/articles/0014/0014-qwikWeb.html" data-text="qwikWeb の仕組み 【第 3 回】 ページの一部分だけ編集できるようにしてみる">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                        </div>
                        <p>書いた人：えと こういちろう</p>

<ul id="markdown-toc">
  <li><a href="#ページの一部分だけ編集できるようにしてみる" id="markdown-toc-ページの一部分だけ編集できるようにしてみる">ページの一部分だけ編集できるようにしてみる</a>    <ul>
      <li><a href="#目的" id="markdown-toc-目的">目的</a></li>
    </ul>
  </li>
  <li><a href="#セットアップ方法" id="markdown-toc-セットアップ方法">セットアップ方法</a></li>
  <li><a href="#部分編集プラグインの作り方" id="markdown-toc-部分編集プラグインの作り方">部分編集プラグインの作り方</a>    <ul>
      <li><a href="#インラインプラグインとブロックプラグインの違い" id="markdown-toc-インラインプラグインとブロックプラグインの違い">インラインプラグインとブロックプラグインの違い</a></li>
      <li><a href="#ブロックプラグインの詳細" id="markdown-toc-ブロックプラグインの詳細">ブロックプラグインの詳細</a></li>
      <li><a href="#ページの部分編集を可能とする" id="markdown-toc-ページの部分編集を可能とする">ページの部分編集を可能とする</a></li>
      <li><a href="#テーブル編集プラグイン" id="markdown-toc-テーブル編集プラグイン">テーブル編集プラグイン</a></li>
      <li><a href="#pov-ray-プラグイン" id="markdown-toc-pov-ray-プラグイン">POV-Ray プラグイン</a></li>
      <li><a href="#授業における-wiki-の利用" id="markdown-toc-授業における-wiki-の利用">授業における Wiki の利用</a></li>
    </ul>
  </li>
  <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a></li>
  <li><a href="#著者について" id="markdown-toc-著者について">著者について</a></li>
  <li><a href="#qwikweb-の仕組み-連載一覧" id="markdown-toc-qwikweb-の仕組み-連載一覧">qwikWeb の仕組み 連載一覧</a></li>
</ul>

<h2 id="ページの一部分だけ編集できるようにしてみる">ページの一部分だけ編集できるようにしてみる</h2>

<p>前回は qwikWeb のプラグインの書き方について解説した。今回はそこから発
展させ、ページの一部分だけを編集できるようにしてみる。</p>

<h3 id="目的">目的</h3>

<p>一般に文書は、テキストだけではなく他の要素の集合として成り立つ。例えば
ある一つの文書には、テキスト要素の他に、図やグラフ、表などの要素が含ま
れていることがある。</p>

<p>HTML による文書の場合、文書内に図を挿入したい時は IMG タグを使ってイン
ライン画像として挿入する。HTML そのものには図を記述する能力はない。
IMG タグを使って外部の画像を読み込むしかない。
<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>
XHTML の場合も同様にテキストを記述することしかできないが、XML は他の XML 
要素を混在させることができるため、例えば XHTML の記述の中に SVG による
図を混ぜることができる。つまり、地の文と図版とを、同じ一つのファイル中
に同居させることができる。</p>

<p>前者の場合、図が埋め込まれた一つの文書は HTML ファイルと画像ファイルの
二つに分割されることになる。HTML はエディタで修正し、画像ファイルは画
像編集ソフトでの編集と、編集手段も二つに分かれる。XHTML のファイル内
に SVG を混在させた場合は、その両者ともテキストエディタで同時に編集で
きる。つまりエディタによる編集という一つの手段で両者を一度に編集できる
ことになる。
<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>一般に Wiki エンジンでは、Wiki 記法によってテキストを編集して、それが
HTML または XHTML としてレンダリングされる。その中に図を埋め込む場合は、
画像ファイルを別要素として埋め込むことになる。つまり HTML と同じ方式で
ある。
<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></p>

<p>Wiki はネット上で気軽に使える共同編集環境であるが、現状では主にテキス
トの共同編集に留まっている。テキスト以外の、図などの要素も含めて、同じ
ように共同編集が行えるとすばらしいのではないだろうか。</p>

<p>また、それらのテキスト以外の要素は、本体となる Wiki ページの編集とは独
立して編集できると都合がいいだろう。例えば表の編集は、表の見た目のまま
編集したい。図の編集は、図を見たとおりのまま編集できるとうれしい。この
ような埋め込まれた要素の編集は、その要素がページを構成する一部分である
ととらえるとすると、ページの部分編集であるととらえることができる。その
ような、ページの部分編集を行えるような仕組みを考えてみたい。</p>

<p>本稿ではそのようなテキスト以外の要素を埋め込み、またそれら個別の要素を
それぞれ部分的に編集できるようにするプラグインを作成してみることを目標
とする。</p>

<h2 id="セットアップ方法">セットアップ方法</h2>

<p>今回もまた、セットアップ方法について解説しておく。</p>

<p>qwikWeb は、メーリングリストと Wiki が統合されているという特徴を持って
いるが、プログラムの構成としてはメーリングリストサーバと Wiki サーバは、
それぞれ独立した別のプロセスとして動く仕組みになっている。
そのため、
メーリングリストサーバだけ、Wiki サーバだけをそれぞれ別個に起動させる
ことができる。今回この連載では、Wiki サーバにおける機能拡張の方法だけ
扱っているため、Wiki サーバ部分のセットアップ方法だけを解説する。</p>

<p>メーリングリストサーバのインストールは、Wiki サーバのインストールと比
較して難しい。DNS、メールサーバなどの設定を適切に行う必要があり、それ
ら全てを適切に設定しないと動くようにならないからである。技術評論社の 
Software Design 2006 年 5 月号に qwikWeb の徹底解説記事を書いた。本記事に
は qwikWeb のメーリングリスト機能を含めたインストール方法を解説してお
り、こちらを御参照下さい。また、下記 URL に Debian 環境でのインストー
ル方法を解説しており、記事内容とほぼ同等の記述があるので、こちらも御参
照下さい。</p>

<ul>
  <li><a href="http://qwik.jp/InstallOnDebian.html">http://qwik.jp/InstallOnDebian.html</a></li>
</ul>

<p>下記では、qwikWeb の開発版をインストールし、Wiki サーバ部分だけを動か
せるようにする方法について説明する。まず「 ~/qwik 」以下に qwikWeb を
インストールすると仮定する。リポジトリより最新版を取得する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% cd
% svn checkout svn://rubyforge.org//var/svn/qwik/qwik</code></pre></figure>

<p>このようにして最新版を取得する。次に、qwikWeb を起動する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% cd qwik
% make
[2006-01-26 08:53:26] INFO  WEBrick 1.3.1
[2006-01-26 08:53:26] INFO  ruby 1.8.4 (2005-10-29) [i486-linux]
[2006-01-26 08:53:36] INFO  Qwik::Server#start: pid=2345 port=9190</code></pre></figure>

<p>このようにして、取得したディレクトリからデバッグモードで起動することが
できる。make コマンドが使えない環境では、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% cd qwik
% ruby bin/qwikweb-server -d -c etc/config.txt</code></pre></figure>

<p>としても同じことになる。</p>

<p>qwikWeb が起動すると WEBrick の起動メッセージが表示される。</p>

<ul>
  <li><a href="http://127.0.0.1:9190/">http://127.0.0.1:9190/</a></li>
</ul>

<p>にアクセスしてみると、qwikWeb の入口となるページが表示される。</p>

<p>qwikWeb サーバは通常はポート 9190 で立ち上がるが、ポート 80 からアクセ
スできるようにしたい場合には二つ方法がある。まず、設定を書換えてポート 
80 で立ち上がるようにすることができる。しかし通常はポート 80 では 
Apache などの別のサーバがすでに動いているため、そちらを停止する必要が
ある。もう一つの方法としては、その Apache などの httpd をリバースプロ
キシとして動くように設定する方法がある。設定方法は、下記 URL を御参照下
さい。</p>

<ul>
  <li><a href="http://qwik.jp/UseWithApache.html">http://qwik.jp/UseWithApache.html</a></li>
</ul>

<h2 id="部分編集プラグインの作り方">部分編集プラグインの作り方</h2>

<p>前回は、qwikWeb の基本的なプラグインの作り方について述べた。</p>

<h3 id="インラインプラグインとブロックプラグインの違い">インラインプラグインとブロックプラグインの違い</h3>

<p>プラグインには、通常のプラグイン(インラインプラグイン)と、複数行プラグ
イン(ブロックプラグイン)との二種類あることはすでに前回説明した。もう一度、
簡単にその違いを見てみる。</p>

<p>実例で比較すると、インラインプラグインは、このようになる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{hello(world)}}</code></pre></figure>

<p>ブロックプラグインは、このようになる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{bhello
 world
 }}</code></pre></figure>

<p>どちらも、「hello」というプラグインに「world」という引数を与えている
ことには変わりないが、その書き方が違う。また出現可能な要素も違う。</p>

<p>前者のインラインプラグインでは、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">私は「{{hello(world)}}」と言った。</code></pre></figure>

<p>などと、文中に埋込む形でこのプラグインを使うことができる。
そのため、これをインラインプラグインと呼んでいる。</p>

<p>後者のブロックプラグインでは、このように文中に埋め込んで使う方法は
とれない。その代りに、引数として複数行とることができる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{bhello
 world
 japan
 tokyo
 }}</code></pre></figure>

<p>などというように、プラグインに三行分の情報を渡すことができる。
<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup></p>

<p>このように、この二つのプラグインは、見た目としては結構似ているが、与え
ることができる情報には大きな違いがある。</p>

<p>今回は、主にこの後者のブロックプラグインを対象として扱う。</p>

<h3 id="ブロックプラグインの詳細">ブロックプラグインの詳細</h3>

<p>ブロックレベルプラグインは、どのように情報を受け取るのか。試しに、最も
簡単な pre プラグインを見てみよう。</p>

<ul>
  <li>qwik/lib/qwik/act-basic.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">module Qwik
  class Action
    def plg_pre
      content = yield
      return [:pre, content]
    end
  end
end</code></pre></figure>

<p>このようになる。これが pre プラグインの全体像である。一行づつ見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     content = yield</code></pre></figure>

<p>yield で、ブロックにかこまれたテキストを取得する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     return [:pre, content]</code></pre></figure>

<p>pre タグで囲ってその内容を返す。これだけである。</p>

<p>ちなみにインラインレベルの場合は、プラグインへの引数として渡される。
インラインプラグインとブロックプラグインの違いは、
Ruby における、引数渡しと、ブロック渡しの違いとほぼ同じような違いとし
て実装している。</p>

<p>先程の例にあげた、bhello プラグインについて見てみよう。
これはブロックプラグインであり、一行づつにhelloをつけて出力するプラグインである。</p>

<ul>
  <li>qwik/lib/qwik/act-hello.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">module Qwik
  class Action
    def plg_bhello
      content = yield
      content = content.map {|line|
	"hello, #{line.chomp}!\n"
      }.join
      return [:pre, content]
    end
  end
end</code></pre></figure>

<p>一行づつ見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     content = yield</code></pre></figure>

<p>囲まれた内容を取得する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     content = content.map {|line|
       "hello, #{line.chomp}!\n"
     }.join</code></pre></figure>

<p>一行づつ取り出し、その行を「hello, …!」で囲い、また連結する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     return [:pre, content]</code></pre></figure>

<p>pre タグで囲って返す。</p>

<p>このようにして、ブロックプラグインを書くことができる。</p>

<h3 id="ページの部分編集を可能とする">ページの部分編集を可能とする</h3>

<p>一番簡単なサンプルとして textarea プラグインを見てみよう。</p>

<ul>
  <li><a href="http://qwik.jp/PluginTextarea.describe">http://qwik.jp/PluginTextarea.describe</a></li>
</ul>

<p>これが使い方である。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{textarea
 This is an example for textarea.
 }}</code></pre></figure>

<p>といった感じにプラグインを埋め込むと、そこに編集可能なテキストエリアが
表れる。ソースを見てみる。</p>

<ul>
  <li>qwik/lib/qwik/act-textarea.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">module Qwik
  class Action
    TEXTAREA_MIN_COLS = 50
    TEXTAREA_MIN_ROWS = 4
    TEXTAREA_MAX_COLS = 100
    TEXTAREA_MAX_ROWS = 50
    def plg_textarea
      # @textarea_num is global for an action.
      @textarea_num = 0 if ! defined?(@textarea_num)
      @textarea_num += 1
      action = "#{@req.base}.#{@textarea_num}.textarea"

      content = ''
      content = yield if block_given?

      cols = rows = 1
      content.each {|line|
	len = line.chomp.length
	cols = len if cols &lt; len
	rows += 1
      }
      cols = TEXTAREA_MIN_COLS if cols &lt; TEXTAREA_MIN_COLS
      rows = TEXTAREA_MIN_ROWS if rows &lt; TEXTAREA_MIN_ROWS
      cols = TEXTAREA_MAX_COLS if TEXTAREA_MAX_COLS &lt; cols
      rows = TEXTAREA_MAX_ROWS if TEXTAREA_MAX_ROWS &lt; rows

      return [:div, {:class=&gt;'textarea'},
	[:form, {:method=&gt;'POST', :action=&gt;action},
	  [:textarea, {:name=&gt;'t', :cols=&gt;cols, :rows=&gt;rows}, content],
	  [:br],
	  [:input, {:type=&gt;'submit', :value=&gt;_('Update')}]]]
    end
  end
end</code></pre></figure>

<p>部分毎に見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     # @textarea_num is global for an action.
     @textarea_num = 0 if ! defined?(@textarea_num)
     @textarea_num += 1
     action = "#{@req.base}.#{@textarea_num}.textarea"</code></pre></figure>

<p>一つのページ中に、テキストエリアプラグインは何個も埋め込める。そのため、
それぞれに連番を振って対処している。そのための連番を指定して、それに対
応する action の URL を組み立てている。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     content = ''
     content = yield if block_given?</code></pre></figure>

<p>ブロックの中身を取得している。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     cols = rows = 1
     content.each {|line|
        len = line.chomp.length
        cols = len if cols &lt; len
        rows += 1
     }</code></pre></figure>

<p>content の内容から、cols と rows の大きさを取得している。それぞれ行の
長さと行数のそれぞれを取得して、content の大きさにあわせて textarea の
大きさが変化するようにしている。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     cols = TEXTAREA_MIN_COLS if cols &lt; TEXTAREA_MIN_COLS
     rows = TEXTAREA_MIN_ROWS if rows &lt; TEXTAREA_MIN_ROWS
     cols = TEXTAREA_MAX_COLS if TEXTAREA_MAX_COLS &lt; cols
     rows = TEXTAREA_MAX_ROWS if TEXTAREA_MAX_ROWS &lt; rows</code></pre></figure>

<p>それぞれ、最小値と最大値の間におさまるようにしている。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     return [:div, {:class=&gt;'textarea'},
        [:form, {:method=&gt;'POST', :action=&gt;action},
          [:textarea, {:name=&gt;'t', :cols=&gt;cols, :rows=&gt;rows}, content],
          [:br],
          [:input, {:type=&gt;'submit', :value=&gt;_('Update')}]]]</code></pre></figure>

<p>ここで html を出力する。まずテストするときに切り出しが楽なように、
textarea クラスの div で囲う。次に form 要素を作る。先程組み立てた URL 
を action とする。肝心の textarea 要素を cols, rows, content で作る。
name は適当に決めておく。更新のための submit ボタンを作る。</p>

<p>これで全てである。このプラグインを表示すると、テキストエリアが表示され、
そこに適当なテキストを入力することができる。それだけならば単にテキスト
エリアが表示されているというだけなのだが、それだけではなく、それを更新
することができる。更新ボタンを押すと、ページのそのテキストエリアの部分
だけが更新されるのだ。</p>

<p>その更新処理は、ext_textarea メソッドで行っている。実際の処理を見てみる。</p>

<ul>
  <li>qwik/lib/qwik/act-textarea.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">module Qwik
  class Action
    def ext_textarea
      c_require_post
      c_require_page_exist

      num = @req.ext_args[0].to_i
      return c_nerror(_('Error')) if num &lt; 1

      text = @req.query['t']
      return c_nerror(_('No text')) if text.nil? || text.empty?
      text = text.normalize_newline

      begin
	plugin_edit(:textarea, num) {|content|
	  text
	}
      rescue NoCorrespondingPlugin
	return c_nerror(_('Failed'))
      rescue PageCollisionError
	return mcomment_error(_('Page collision detected.'))
      end

      c_make_log('textarea')	# TEXTAREA

      url = "#{@req.base}.html"
      return c_notice(_('Edit text done.'), url){
	[[:h2, _('Edit text done.')],
	  [:p, [:a, {:href=&gt;url}, _('Go back')]]]
      }
    end
  end
end</code></pre></figure>

<p>どんな処理をしているのか見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     c_require_post
     c_require_page_exist</code></pre></figure>

<p>リクエストは POST である必要がある。また、対象となるページが存在してい
る必要がある。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     num = @req.ext_args[0].to_i
     return c_nerror(_('Error')) if num &lt; 1</code></pre></figure>

<p>この ext_args というメソッドは、リクエスト URL のうち base と ext に挾
まれた引数を持ってくるというメソッドである。実例を示すと、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">http://qwik.jp/test/FrontPage.1.textarea</code></pre></figure>

<p>という URL では、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@req.base =&gt; "FrontPage"
@req.ext_args =&gt; ["1"]
@req.ext =&gt; "textarea"</code></pre></figure>

<p>という対応関係となる。大抵は、base が処理対象となるページ、ext が処理
内容を表わしている。その二つに囲まれる領域にも引数を追加することができ、
ext_args に配列として入る。普通だったらこれは「?」の後に情報を追加すると
ころであるが、あえてその方法は使っていない。
<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>
ここでは、何番目の textarea プラグインを対象としているのかの値が入っている。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     text = @req.query['t']
     return c_nerror(_('No text')) if text.nil? || text.empty?
     text = text.normalize_newline</code></pre></figure>

<p>入力されたテキストを取得する。もし中身が無ければエラーとする。入力テキ
ストは改行が場合によって異なるかもしれないため、統一する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     begin
        plugin_edit(:textarea, num) {|content|
          text
        }
     rescue NoCorrespondingPlugin
        return c_nerror(_('Failed'))
     rescue PageCollisionError
        return mcomment_error(_('Page collision detected.'))
     end</code></pre></figure>

<p>ここがこのプラグインの肝である。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        plugin_edit(:textarea, num) {|content|
          text
        }</code></pre></figure>

<p>plugin_edit は、渡されたブロックの値でプラグインの中身を置き換えるメソッド
である。したがって、
この三行で、num 番目の textarea というプラグインの中身を、text に置き換
えるという意味となる。content にはいるのは現在の中身である。
この例では現在の中身は使用していないが、必要であればこれを
元にして処理をさせることもできる。もしこの書換え実行時にエラー
がおきたら、Exception が raise されるため、それを拾ってエラーページに
飛ばす。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     c_make_log('textarea')	# TEXTAREA</code></pre></figure>

<p>ここで、ログに記録を残す。この c_make_log を使ってログを残すと、それは
一日に一回まとめて更新記録として送られる。このプラグインのように、ペー
ジの更新を行うプラグインの場合は、この c_make_log を使って更新通知が送
られるようにしておくと、グループのメンバーは全てその更新に気がつくので
便利である。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     url = "#{@req.base}.html"
     return c_notice(_('Edit text done.'), url){
        [[:h2, _('Edit text done.')],
          [:p, [:a, {:href=&gt;url}, _('Go back')]]]
     }</code></pre></figure>

<p>ここで、無事テキストの書換えが終了したので、元のページに戻る。</p>

<p>このようにして、更新ボタンが押された後のページの書き換え処理を行ってい
る。まずプラグインで textarea を表示して、そこで更新ボタンが押されると、
ページの内のそのプラグインの部分だけが部分的に書換えられて、更新される
というわけである。このようにして、もっとも基本的なページの部分書き換え
が行われている。</p>

<h3 id="テーブル編集プラグイン">テーブル編集プラグイン</h3>

<p>この最も基本的な textarea プラグインだけを見ていると、部分編集といって
も何が便利なんだろうという気がしてくるかもしれない。なので、実際に実用的に
使っているテーブル編集プラグインについて見てみる。</p>

<ul>
  <li><a href="http://qwik.jp/PluginTable.describe">http://qwik.jp/PluginTable.describe</a></li>
</ul>

<p>使い方として、実際の具体例を見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{table
 |Date|Ｓ|Ｎ|Ｈ|E|Ｓ|Ｉ|Ｍ|
 |2005-01-18am|×|×|×|×|　|○|○|
 |2005-08-18pm|○|×|×|×|　|○|○|
 |2005-08-19am|×|×|○|×|　|○|○|
 |2005-08-19pm|×|×|△|×|　|○|○|
 |2005-08-22am|○|○|×|○|　|×|×|
 |2005-08-22pm|○|×|○|△|　|○|○|
 |2005-08-23am|△|○|○|△|　|○|○|
 |2005-08-23pm|△|△|×|○|　|3時以降|○|
 }}</code></pre></figure>

<p>このように普通の Wiki テキストと同じ形式で table を書いて、それを 
table プラグインで囲むと、その table が編集できるようになる。Wiki テキ
スト形式で table を編集するのは一般にはやりづらいが、このプラグインを
使うと、ページ中でその表を見たままの状態で編集できるようになる。</p>

<p>プラグインの内部を見てみてよう。</p>

<ul>
  <li>qwik/lib/qwik/act-table.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">    def plg_table
      content = nil
      content = yield if block_given?

      if content.nil? || content.empty?		# no contents
	content = Action.table_default_content
      end

      w = c_parse(content)
      return p_error(_('You can only use a table.')) if 1 &lt; w.length

      table = w[0]
      if table.nil? || table[0] != :table
	return p_error(_('You can only use a table.'))
      end

      if WabisabiTable.error_check(table)
	return p_error(_('You can only use text.'))
      end

      WabisabiTable.prepare(table)

      # @table_num is global for an action.
      @table_num = 0 if !defined?(@table_num)
      @table_num += 1
      num = @table_num

      action = "#{@req.base}.#{num}.table"
      div = [:div, {:class=&gt;'table'},
	[:form, {:method=&gt;'POST', :action=&gt;action},
	  table,
	  [:div, {:class=&gt;'submit'},
	    [:input, {:type=&gt;'submit', :value=&gt;_('Update')}]]]]
      return div
    end</code></pre></figure>

<p>先程のプラグインとの繰り返しが多いため、一部分だけ解説する。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     w = c_parse(content)</code></pre></figure>

<p>これで、content の中身をわびさび形式の配列に直している。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     WabisabiTable.prepare(table)</code></pre></figure>

<p>実際のところ、重要な処理をしているのはこの一行だけである。
WabisabiTable.prepare の具体的な中身を見てみる。</p>

<ul>
  <li>qwik/lib/qwik/act-table.rb</li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">   def self.prepare(table)
     fill_empty_td(table)
     add_new_col(table)
     add_new_row(table)
     replace_with_input(table)
     make_th(table)
     set_new_col_and_new_row(table)
     add_new_col_button(table)
     add_new_row_button(table)
     return table
   end</code></pre></figure>

<p>処理ごとに関数に分けている。わびさび形式の table 要素を受け取り、それ
を適宜必要な形式に変換していっている。これはまさしく初回の記事で紹介し
た、HTML を受け取り、必要な HTML に変換して返すという処理である。つま
り、この WabisabiTable.prepare は、特別なデータを受け取って HTML にして返
しているのではなく、任意の HTML による table 要素を必要な形式に変換す
ることができる関数となっている。このようにして、処理の汎用化を進めてい
る。このようにして、table 要素を受け取り、table 形式のフォームに変換し
て出力している。</p>

<p>次に、更新が押されたらどのような処理が行われるのかを見てみる。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">    def ext_table
      num = @req.ext_args[0].to_i
      return c_nerror(_('Error')) if num &lt; 1

      query = @req.query
      new_table_str = table_construct(query)

      begin
	plugin_edit(:table, num) {
	  new_table_str
	}
      rescue NoCorrespondingPlugin
	return c_nerror(_('Failed'))
      rescue PageCollisionError
	url = "#{@req.base}.html"
	editing_content = [:pre, new_table_str]
	message = edit_conflict_message(url, editing_content)
	return mcomment_error(_('Page collision detected.')) {
	  message
	}
      end

      c_make_log('table')	# TABLE

      url = "#{@req.base}.html"
      return c_notice(_('Edit done.'), url){
	[[:h2, _('Edit done.')],
	  [:p, [:a, {:href=&gt;url}, _('Go back')]]]
      }
    end</code></pre></figure>

<p>実は先程のテキストエリアプラグインと処理はほとんど同じである。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">     query = @req.query
     new_table_str = table_construct(query)

     begin
        plugin_edit(:table, num) {
          new_table_str
        }</code></pre></figure>

<p>ここが処理の肝である。クエリの内容から再度 Wiki テキスト表記による 
table に書き戻し、それから、その対応するプラグインの中身を置き換えているわ
けである。このようにして、テーブル編集プラグインは実現されている。
<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>先程の textarea プラグインの場合は、編集したテキストがそのまま入力となった。
しかし、テーブル編集プラグインの場合は、編集時のスタイル (HTML で描画されたテーブル) と、
入力となるテキスト (テーブルの Wiki 記法) が異なっている。
このように、プラグインの中身の性質の違いによって、
編集のスタイルを変更できるというのが、ページの部分的編集の肝なのである。</p>

<h3 id="pov-ray-プラグイン">POV-Ray プラグイン</h3>

<p>さて、このようにページの部分編集を行うプラグインを二種類見てきた。これ
をふまえた上で、ページの部分編集を行うプラグインを新たに一つ作ってみる。
POV-Ray プラグインというのを作ってみることにした。POV-Ray とは、レイト
レーシングによって 3D CG をレンダリングするアプリケーションである。</p>

<p>POV-Ray の説明は、下記ページを見てほしい。</p>

<ul>
  <li><a href="http://www.povray.org/">http://www.povray.org/</a></li>
</ul>

<p>POV-Ray の本拠地である。</p>

<ul>
  <li><a href="http://eto.com/d/PovRay.html">http://eto.com/d/PovRay.html</a></li>
</ul>

<p>サンプルなどについては、このページにまとめておいた。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># apt-get install povray-3.6 povray-3.6-examples</code></pre></figure>

<p>Debian の場合はこのようにして install できる。
<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup></p>

<ul>
  <li><a href="http://qwik.jp/PluginPovray.describe">http://qwik.jp/PluginPovray.describe</a></li>
</ul>

<p>このページに完成した POB-Ray プラグインの使い方がでている。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{{povray
 union{sphere{z*9-1,2}plane{y,-3}finish{reflection{,1}}}background{1+z/9}
}}</code></pre></figure>

<p>ページ中にこのようにプラグインを記述すると、そのプラグインに書かれた記
述を元に POV-Ray が起動し、その結果としての画像が埋め込まれる仕組みに
なっている。また上記のテキストエリアプラグインとほぼ同じように、
POV-Ray に入力するレイトレーシングのソースコードをその場で編集して更新
できる。このようにすると、3D CG のコードをその場で書換えながらちょっと
づつ直していくことができる。
(このサンプルは、<a href="http://astronomy.swin.edu.au/~pbourke/raytracing/scc3/final/">POVRay Short Code Contest, Round 3</a>より引用させていただきました。
)</p>

<ul>
  <li>qwik/lib/qwik/act-povray.rb</li>
</ul>

<p>こちらにソースコードがある。
肝となる、コードの実行部分だけ見てみよう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">   def povray_generate(content)
     files = @site.files(@req.base)
     base = content.md5hex
     filename = "#{base}.pov"
     pngfilename = "#{base}.png"
     return pngfilename if files.exist?(filename)

     files.overwrite(filename, content)
     # Render it background.
     t = Thread.new {
        path = files.path(filename)
        pngpath = files.path(pngfilename)
        pngtmppath = "/tmp/#{pngfilename}"
        system "#{POVRAY_CMD} #{path} -O#{pngtmppath}"
        system "#{MV_CMD} #{pngtmppath} #{pngpath}"
     }
     return pngfilename
   end</code></pre></figure>

<p>このようにして、テキストの内容の md5hex を取得して、それを元にファイル
名を作っている。こうすることによって、テキスト内容が変更したら再度レン
ダリングするという仕組みを容易に実現している。</p>

<h3 id="授業における-wiki-の利用">授業における Wiki の利用</h3>

<p>普通に考えると、このような 3D CG のレンダリングだったら、直接自分のマ
シンで動かした方が良さそうに思えるかもしれない。しかし、教育目的を考え
ると、この仕組みは大変使えるように思う。例えば POV-Ray を使って作品を
作る授業を考えてみよう。通常であれば、まず最初にアプリケーションのイン
ストールから授業を始めるのだが、この仕組みがあれば最初は Wiki ページ中
の POV-Ray プラグインを使って使いはじめることができる。そして、少し慣
れてきてからアプリケーションのインストール方法を教えるというように、段
階を追って進めることができる。</p>

<p>「アプリケーションをインストールするくらい簡単じゃん」と思う人もいるか
もしれない。しかし、例えば大学一年生への授業を考えると、まだコンピュー
タを持ってない人も結構いる。場合によっては、まだ一度もパソコンを触った
ことが無い人さえいる。そのような場合には、このように入口の敷居を低くす
るための仕組みは、大変有効である。</p>

<p>また、POV-Ray の使い方を説明するためのドキュメントを作るのにも役に立つ
だろう。普通は、POV-Ray のソースとレンダリング結果の組が繰り返し出てく
るものになる。そのような文章を編集するには、この仕組みは大変役立つだろ
う。最終的にみんなの作品をオンラインで見ることができるようにするのにも
使えるだろう。</p>

<p>Wiki ページとして実現していることの利点は他にもある。自動的に編集履歴
が残るため、作品制作の過程がそのまま残ることになる。つまり、これまでレ
ンダリングしてきたソースと画像の組が全て自動的に残るのである。qwikWeb 
にはタイムマシーンモードという過去の編集履歴をインタラクティブに見るこ
とができる仕組みが用意されているため、このモードと組み合わせると過去の
レンダリングの変遷をまるで動画のように見ることができる。これは実際にやっ
てみると予想以上に面白かったのでおすすめである。</p>

<p>ここにあげた仕組みは、テキストによるソースと、その結果の表示の繰り返し
からなるアプリケーションであれば同様に扱うことができる。あてはまる事例
がありましたら、ぜひトライしてみるといいかもしれません。</p>

<h2 id="まとめ">まとめ</h2>

<p>Wiki ページ中には、プラグインによって複数の種類の要素を埋め込むことが
できる。その埋め込まれたそれぞれの要素を、個別に編集できるようにすると
大変便利である。Web ブラウザだけでその埋め込まれた要素を編集できるよう
になるので、一番最初に取り組む際の敷居を下げることができる。授業などに
おける利用を考えると、このような仕組みは大きな意義があると考えられる。</p>

<h2 id="著者について">著者について</h2>

<p>えと こういちろう (Rubyist)。</p>

<p>Rubyist の割には、YAPC に参加してるし、Shibuya.js では発表までしてます。</p>

<ul>
  <li><a href="http://shibuyajs.org/articles/2006/03/27/shibuya-js-technical-talk-1">http://shibuyajs.org/articles/2006/03/27/shibuya-js-technical-talk-1</a></li>
</ul>

<h2 id="qwikweb-の仕組み-連載一覧">qwikWeb の仕組み 連載一覧</h2>

<ul>
  <li>
    <p><a href="/articles/0014/0014-qwikWeb.html">qwikWeb の仕組み 【第 3 回】 ページの一部分だけ編集できるようにしてみる</a></p>
  </li>
  <li>
    <p><a href="/articles/0013/0013-qwikWeb.html">qwikWeb の仕組み 【第 2 回】 qwikWeb のプラグインを作ってみよう</a></p>
  </li>
  <li>
    <p><a href="/articles/0012/0012-qwikWeb.html">qwikWeb の仕組み 【第 1 回】 コンテンツ・フレームワークとしての qwikWeb</a></p>
  </li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>一応、アスキーアートで表現するという手もありますね。&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>実際のところ、SVG のような画像をエディタで編集するのは難しい。不可能に近い。しかし、ここでは可能性について論じていると解釈してほしい。&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Wiki エンジンとしては例外的に、MediaWiki ではページ中への図の埋め込みに対応している。Wiki のテキストに同じように図を指定すると、SVG 要素としてページに埋め込まれるようになる。&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>ここではあえて、hello と bhello と二つのプラグイン名を変えている。しかし、一つのプラグインでインラインとブロックの両方に対応するようにすることもできる。&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>「?」が嫌いだからなんですね。というか、URL が汚なくなるのが嫌いなんですね。&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>このようにほとんど同じような処理がほんのちょっとだけ変えられて出現するのは好ましくない。リファクタリングしたいところである。&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>この POV-Ray は、実はいわゆるオープンソースではない。正確には、Debian フリーソフトウェアガイドラインに準拠したライセンスではない。そのため non-free を使えるようにしていないと、apt-get では入れられない。なぜ POV-Ray がいわゆるオープンソースではないのかは、<a href="http://nishimulabo.edhs.ynu.ac.jp/~povray/3.5jp/povdoc_361.htm">POV-Ray 法規</a>のページで確認できる。&nbsp;<a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
