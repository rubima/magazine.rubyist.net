<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>詳解! test-all 並列化</title>
  <meta name="description" content="">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/css/theme.css" rel="stylesheet" type="text/css">
  <link href="/css/syntax.css" rel="stylesheet" type="text/css">

  <link rel="canonical" href="http://magazine.rubyist.net/articles/0033/0033-ParallelizeTestAll.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="http://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="/images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-1 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="/articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="/articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="/articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="/articles/pretokyorubykaigi11/preTokyoRubyKaigi11.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="/articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="/articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="/articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="/articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="/articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="/articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="/articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="/articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="/articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="/articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="/articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="/articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="/articles/ruby200specialen/Ruby200SpecialEn.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="/articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="/articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="/articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="/articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="/articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="/articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="/articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="/articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="/articles/prerubykaigi2011/preRubyKaigi2011.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="/articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="/articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="/articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="/articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="/articles/prerubykaigi2010/preRubyKaigi2010.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="/articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="/articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="/articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="/articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="/articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="/articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="/articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="/articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="/articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="/articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="/articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="/articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="/articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="/articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="/articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="/articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="/articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="/articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="/articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="/articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="/articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="/articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="/articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="/articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="/articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="/articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="/articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="/articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="/articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="/articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="/articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-11 main">
                <img src="/images/rubima_logo_l.png">
                <h1>詳解! test-all 並列化</h1>
                <div class="social-buttons">
                    <a href="http://b.hatena.ne.jp/entry//articles/0033/0033-ParallelizeTestAll.html" class="hatena-bookmark-button" data-hatena-bookmark-title="詳解! test-all 並列化" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<span id="fb-root"></span>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.5";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<span class="fb-like" data-href="/articles/0033/0033-ParallelizeTestAll.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></span>
<a href="https://twitter.com/share" class="twitter-share-button" data-url="/articles/0033/0033-ParallelizeTestAll.html" data-text="詳解! test-all 並列化">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                </div>
                <ul id="markdown-toc">
  <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a>    <ul>
      <li><a href="#対象読者" id="markdown-toc-対象読者">対象読者</a></li>
      <li><a href="#筆者環境について" id="markdown-toc-筆者環境について">筆者環境について</a></li>
    </ul>
  </li>
  <li><a href="#背景" id="markdown-toc-背景">背景</a>    <ul>
      <li><a href="#test-all-とは" id="markdown-toc-test-all-とは">test-all とは</a></li>
      <li><a href="#test-all-の問題点とその解決案" id="markdown-toc-test-all-の問題点とその解決案">test-all の問題点と、その解決案</a></li>
      <li><a href="#並列化の方針" id="markdown-toc-並列化の方針">並列化の方針</a></li>
      <li><a href="#パッチの提出" id="markdown-toc-パッチの提出">パッチの提出</a></li>
    </ul>
  </li>
  <li><a href="#実装" id="markdown-toc-実装">実装</a>    <ul>
      <li><a href="#master-と-worker-のプロセス間通信プロトコル" id="markdown-toc-master-と-worker-のプロセス間通信プロトコル">master と worker のプロセス間通信プロトコル</a>        <ul>
          <li><a href="#master--worker" id="markdown-toc-master--worker">master → worker</a></li>
          <li><a href="#worker--master" id="markdown-toc-worker--master">worker → master</a></li>
        </ul>
      </li>
      <li><a href="#master-の実装" id="markdown-toc-master-の実装">master の実装</a>        <ul>
          <li><a href="#並列実行用のコマンドラインオプションを追加" id="markdown-toc-並列実行用のコマンドラインオプションを追加">並列実行用のコマンドラインオプションを追加</a></li>
          <li><a href="#master-ではテストファイルを-require-しない" id="markdown-toc-master-ではテストファイルを-require-しない">master ではテストファイルを require しない</a></li>
          <li><a href="#worker-の起動と停止" id="markdown-toc-worker-の起動と停止">worker の起動と停止</a></li>
          <li><a href="#worker-との通信" id="markdown-toc-worker-との通信">worker との通信</a></li>
          <li><a href="#リトライ機能" id="markdown-toc-リトライ機能">リトライ機能</a></li>
          <li><a href="#testunitrunnerworker-クラス" id="markdown-toc-testunitrunnerworker-クラス">Test::Unit::Runner::Worker クラス</a>            <ul>
              <li><a href="#worker-プロセスの起動" id="markdown-toc-worker-プロセスの起動">worker プロセスの起動</a></li>
              <li><a href="#worker-プロセスとの送受信" id="markdown-toc-worker-プロセスとの送受信">worker プロセスとの送受信</a></li>
              <li><a href="#worker-プロセスへ-run-コマンドの送信" id="markdown-toc-worker-プロセスへ-run-コマンドの送信">worker プロセスへ run コマンドの送信</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#worker-の実装" id="markdown-toc-worker-の実装">worker の実装</a>        <ul>
          <li><a href="#おまじない" id="markdown-toc-おまじない">おまじない</a></li>
          <li><a href="#master-からのコマンド受付" id="markdown-toc-master-からのコマンド受付">master からのコマンド受付</a></li>
          <li><a href="#テストの実行" id="markdown-toc-テストの実行">テストの実行</a></li>
        </ul>
      </li>
      <li><a href="#test-の並列実行への対応" id="markdown-toc-test-の並列実行への対応">test/* の並列実行への対応</a>        <ul>
          <li><a href="#testrubytest_signalrb" id="markdown-toc-testrubytest_signalrb">test/ruby/test_signal.rb</a></li>
          <li><a href="#testrubytest_processrb" id="markdown-toc-testrubytest_processrb">test/ruby/test_process.rb</a></li>
          <li><a href="#testnettest_httpsrb-test_httprb" id="markdown-toc-testnettest_httpsrb-test_httprb">test/net/test_https.rb, test_http.rb</a></li>
          <li><a href="#testcsv" id="markdown-toc-testcsv">test/csv</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#結果" id="markdown-toc-結果">結果</a>    <ul>
      <li><a href="#環境" id="markdown-toc-環境">環境</a></li>
      <li><a href="#データ" id="markdown-toc-データ">データ</a></li>
      <li><a href="#グラフ" id="markdown-toc-グラフ">グラフ</a></li>
      <li><a href="#考察" id="markdown-toc-考察">考察</a></li>
    </ul>
  </li>
  <li><a href="#実際に使用する" id="markdown-toc-実際に使用する">実際に使用する</a></li>
  <li><a href="#協力のおねがい" id="markdown-toc-協力のおねがい">協力のおねがい</a></li>
  <li><a href="#謝辞" id="markdown-toc-謝辞">謝辞</a></li>
  <li><a href="#あとがき" id="markdown-toc-あとがき">あとがき</a></li>
  <li><a href="#著者について" id="markdown-toc-著者について">著者について</a></li>
</ul>

<p>書いた人: Shota Fukumori (<a href="http://twitter.com/sora_h">@sora_h</a>)</p>

<h2 id="はじめに">はじめに</h2>

<p>こんにちは、リアル厨二<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>こと sora_h です。このたび、晴れて Ruby コミッタになりました。お祝いのメッセージをくださった皆さん、ありがとうございました。</p>

<p>本稿では、筆者が Ruby コミッタになるきっかけとなった、test-all の並列化について解説します。</p>

<h3 id="対象読者">対象読者</h3>

<ul>
  <li>Ruby の trunk を引っ張ってきて、ビルドまでできる人</li>
  <li>Ruby 本体の開発に興味がある人<br />(もしくは test-all を実行するのが趣味の人)</li>
</ul>

<h3 id="筆者環境について">筆者環境について</h3>

<p>本稿のコードは Mac OS X 10.6.6 で確認しています。</p>

<p>また、本稿の実装解説などは Ruby の r31140 <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> のコードをベースとしています。
Ruby の開発が進むにつれ本稿の内容は古くなりますが、ご了承下さい。</p>

<h2 id="背景">背景</h2>

<h3 id="test-all-とは">test-all とは</h3>

<p>test-all とは、Ruby の組み込みクラスやメソッドや標準ライブラリがちゃんと動作するかを確認するための Make ターゲットです。</p>

<p>Ruby を ビルドした後、make test-all などで実行することができます。
実行すると test ディレクトリ内にあるテストファイル (test_*.rb) を探し、それらを読み込んで、機能が正常に動作するかのテストを実行します。</p>

<h3 id="test-all-の問題点とその解決案">test-all の問題点と、その解決案</h3>

<p>test-all は大量のテストを実行するために時間がかかります (原稿執筆時点でテストファイルが 620 以上！)。
筆者の環境ですと 5 分から 6 分、ひどいときは 15 分くらいかかります。
テストを実行している間は楽しくないので、やっぱり早く終わる方が良いですよね。</p>

<p>こうした不満を Ruby 札幌のチャットルームで言ったところ、並列化すると良いのではないかという返答が返ってきました。</p>

<blockquote>
  <p>sora_h: test-all を高速化させたい<br />
mrkn: っ並列化<br />
sora_h: 誰かやってるかな<br />
mrkn: さぁ<br /></p>
</blockquote>

<p>これをきっかけに、筆者はプロセスをわけて複数のテストケースを並列に実行するパッチの作成にとりかかりました。</p>

<h3 id="並列化の方針">並列化の方針</h3>

<p>テストの実行を並列化するために、master プロセスと worker プロセスを導入しました (図1)。</p>

<ul>
  <li>master プロセス (以下 master)
    <ul>
      <li>役割: worker を起動し、テストを実行するよう指示します。</li>
      <li>動作: テストするファイル名を worker へ送信し、実行結果を受け取ります。</li>
      <li>ファイル: lib/test/unit.rb</li>
    </ul>
  </li>
  <li>worker プロセス (以下 worker)
    <ul>
      <li>役割: 実際にテストを実行します。</li>
      <li>動作: テストするファイル名を master から受け取り、それを require して中のテストケースを実行し、結果を master に返します。</li>
      <li>ファイル: lib/test/unit/parallel.rb</li>
    </ul>
  </li>
</ul>

<p>master と worker はパイプで繋がっており、後述するプロトコルで通信を行います。</p>

<p>また master は 1 つだけ起動され、worker は指定された数だけ起動されます。
最近のマルチコア CPU であれば、複数の worker を同時に走らせることでテストが並列に実行されるので、結果としてテスト時間が短縮されます。</p>

<p>図1: 並列動作の概要
<img src="/images/0033-ParallelizeTestAll/overview.png" alt="overview.png" /></p>

<h3 id="パッチの提出">パッチの提出</h3>

<p>作成開始から約一週間でまともに動くようになったので、ruby-dev<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> にパッチを投げたところ (<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-dev/43226">ruby-dev:43226</a>)、コミット権がもらえてコミッターになりました。</p>

<p>そこで r30939<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup> でこのパッチをコミットし、その後リファクタリングを行ったり Windows でのバグを直したりして現在に至ります。</p>

<h2 id="実装">実装</h2>

<p>さっそく実装を見ていきましょう。</p>

<p>今回解説するのは主要な処理の部分で、枝葉の部分 (例外処理など) は省いています。
ご了承ください。</p>

<h3 id="master-と-worker-のプロセス間通信プロトコル">master と worker のプロセス間通信プロトコル</h3>

<p>前述したように、master と worker はパイプを利用してプロセス間通信を行っています。
ここでは、そのプロトコルで使われるコマンドとデータを説明します。</p>

<p>なお説明では以下の表記を使っています。</p>

<ul>
  <li>「data<sub>base64</sub>」は base64 でエンコードされたデータを表します。</li>
  <li>「data<sub>marshal</sub>」は base64 でエンコードされた marshal 文字列を表します。</li>
  <li>「data<sub>plain</sub>」は平文の文字列データを表します。</li>
</ul>

<h4 id="master--worker">master → worker</h4>

<dl>
  <dt>loadpath array<sub>marshal</sub></dt>
  <dd>ロードパスの差分です。一部のテストがロードパスを変更するのでそれの対策です。worker はこの配列をロードパスに追加します。</dd>
  <dt>run filename<sub>plain</sub> type<sub>plain</sub></dt>
  <dd>ファイル名とテスト種別 (通常は「test」) を送信してテストの実行を指示します。</dd>
  <dt>quit</dt>
  <dd>worker を終了させます。worker はこれを受け取ると bye を送信して終了します。</dd>
</dl>

<h4 id="worker--master">worker → master</h4>

<dl>
  <dt>ready</dt>
  <dd>ファイルの実行が終了し、ファイルの実行を受け入れ可能になった時に送信されます。</dd>
  <dt>okay</dt>
  <dd>ファイルの実行を開始する時に出力します。</dd>
  <dt>done result<sub>marshal</sub></dt>
  <dd>テストケースの実行が 1 つ終わるごとにその結果を返します。結果は配列であり、テストメソッド数、テストアサーション数、error 数、failure 数、skip 数、ロードパスの差分、テストケース名をこの順で含んでいます。</dd>
  <dt>p string<sub>base64</sub></dt>
  <dd>テストの出力 (「FooTest#test_bar: 1.0s = .」や実行経過を表す「….」など) を返します。</dd>
  <dt>after warning<sub>marshal</sub></dt>
  <dd>LoadError などテストケースの読み込み時に起こったエラーを伝えるときに使用されます。</dd>
  <dt>bye error<sub>marshal</sub></dt>
  <dd>異常終了時の Exception を出力します。</dd>
  <dt>bye</dt>
  <dd>正常終了時に送信されます。コマンドは上と同じですが、引数があれば異常終了、なければ正常終了を表します。</dd>
</dl>

<h3 id="master-の実装">master の実装</h3>

<p>master の実装は lib/test/unit.rb に含まれています。
つまり Ruby 標準のテスティングライブラリ自体に並列化機能を組み込んだことになります。</p>

<p>具体的には、lib/test/unit.rb に次のような変更を行いました。</p>

<ul>
  <li>並列実行用のコマンドラインオプションを追加</li>
  <li>master ではテストファイルを require しない</li>
  <li>worker の起動と停止</li>
  <li>worker との通信</li>
  <li>リトライ機能</li>
</ul>

<p>以下、それぞれを説明します。</p>

<h4 id="並列実行用のコマンドラインオプションを追加">並列実行用のコマンドラインオプションを追加</h4>

<p>lib/test/unit.rb:86 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        opts.on '--jobs-status [TYPE]', "Show status of jobs every file; Disabled when --jobs isn't specified." do |type|
          options[:job_status] = (type &amp;&amp; type.to_sym) || :normal
        end

        opts.on '-j N', '--jobs N', "Allow run tests with N jobs at once" do |a|
          if /^t/ =~ a
            options[:testing] = true # For testing
            options[:parallel] = a[1..-1].to_i
          else
            options[:parallel] = a.to_i
          end
        end

        opts.on '--no-retry', "Don't retry running testcase when --jobs specified" do
          options[:no_retry] = true
        end

        opts.on '--ruby VAL', "Path to ruby; It'll have used at -j option" do |a|
          options[:ruby] = a.split(/ /).reject(&amp;:empty?)
        end</code></pre></figure>

<p>以下のようなコマンドラインオプションを追加しています。</p>

<dl>
  <dt>-j N, –jobs=N</dt>
  <dd>最大 N つのテストケースの並列実行を許可します。指定しなければ worker などは生成せず、従来の動作をします。</dd>
  <dt>–jobs-status, –jobs-status=replace</dt>
  <dd>worker の状態、実行しているファイル名を随時表示します。–jobs-status=replace にするとエスケープシーケンスなどを用いて状態をターミナルの一番下のみに表示するようになり、ログには残らなくなります。</dd>
  <dt>–ruby=RUBY</dt>
  <dd>worker の起動に使う Ruby を指定します。Ruby には自分自身のパスを取得する確実でポータブルな方法が存在しないため、make コマンドからの起動時には起動オプションごと –ruby に渡しています。デフォルトでは RbConfig.ruby になっています。</dd>
  <dt>–no-retry</dt>
  <dd>後述するリトライ機能を無効化します。</dd>
</dl>

<p>また、options[:ruby] は引数付きで渡されても大丈夫なように、split して配列で格納しています。</p>

<p>なお –jobs や -j オプションで worker でなく jobs という名称を使っているのは、make コマンドの -j オプションに合わせたためです。
本稿ではこのオプション名以外は worker で統一します。</p>

<h4 id="master-ではテストファイルを-require-しない">master ではテストファイルを require しない</h4>

<p>lib/test/unit.rb:214 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          begin
            require path unless options[:parallel]
            result = true
          rescue LoadError
            puts "#{f}: #{$!}"
          end</code></pre></figure>

<p>Test::Unit::RequireFiles モジュールで glob されたファイルを require していますが、並列化した場合は master で require する必要がなくなるため、無効化しています。</p>

<p>これによって実はテスト自体の開始が若干早くなり、また require を worker 側で行うので require が遅延評価かつ並列化されるため、テスト全体の実行時間が短縮されます。</p>

<h4 id="worker-の起動と停止">worker の起動と停止</h4>

<p>lib/test/unit.rb:314 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          # Array of workers.
          @workers = @opts[:parallel].times.map {
            worker = Worker.launch(@opts[:ruby],@args)
            worker.hook(:dead) do |w,info|
              after_worker_quit w
              after_worker_down w, *info unless info.empty?
            end
            worker
          }</code></pre></figure>

<p>worker 抽象化クラスのクラスメソッド Worker.launch で worker を起動しています。</p>

<p>Worker クラスについては後述します。</p>

<p>また、worker の異常終了を処理するためにスレッドを起動して監視しています。</p>

<p>lib/test/unit.rb:405 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          watchdog = Thread.new do
            while stat = Process.wait2
              break if @interrupt # Break when interrupt
              w = (@workers + @dead_workers).find{|x| stat[0] == x.pid }.dup
              next unless w
              unless w.status == :quit
                # Worker down
                w.dead(nil, stat[1].to_i)
              end
            end
          end</code></pre></figure>

<p>終了したプロセスの情報を返す Process.wait2 を呼んで子プロセスが終了するまでスレッドをブロックし、終了を監視しています。</p>

<p>もしプロセスの終了を感知した場合でも、^C などで終了しようとしている場合は @interrupt が真になるため、その場合はなにもせず break しています。</p>

<p>worker の配列から終了した Worker のオブジェクトを探し、もし意図した死亡でない場合はその worker プロセスを担当する Worker クラスのオブジェクトに死亡を伝えます。</p>

<p>テストが終了した際の worker の終了処理は ensure 文内で行っています。</p>

<p>lib/test/unit.rb:465 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          shutting_down = true

          watchdog.kill if watchdog</code></pre></figure>

<p>まずは監視用スレッドを終了させ、終了中を示すフラグを true にします。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          @workers.each do |worker|
            begin
              timeout(1) do
                worker.puts "quit"
              end
            rescue Errno::EPIPE
            rescue Timeout::Error
            end
            worker.close
          end</code></pre></figure>

<p>次に全ての worker に quit コマンドを送信し終了を命じます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          begin
            timeout(0.2*@workers.size) do
              Process.waitall
            end
          rescue Timeout::Error
            @workers.each do |worker|
              begin
                Process.kill(:KILL,worker.pid)
              rescue Errno::ESRCH; end
            end
          end</code></pre></figure>

<p>そして全ての子プロセスの終了を待ちます。タイムアウトした場合は SIGKILL で終了させます。</p>

<h4 id="worker-との通信">worker との通信</h4>

<p>lib/test/unit.rb:420 行目から抜粋 (一部省略)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          while _io = IO.select(@ios)[0]
            break unless _io.each do |io|
              break if @need_quit
              worker = @workers_hash[io]</code></pre></figure>

<p>出力があった worker の IO を IO.select を利用して取得し、_io 変数に代入しています。</p>

<p>そしてハッシュを使い Worker オブジェクトを取得しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              break if @need_quit</code></pre></figure>

<p>また、ループの最後でもう出力を待ち受ける必要がない場合はループから抜けるようになっています。</p>

<p>そしてテストが全て終了すると ensure 文に入り、worker の終了、リトライなどを実行します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              case worker.read
              when /^okay$/
                worker.status = :running # ステータスを running に
              when /^ready$/
                worker.status = :ready   # ステータスを ready に
                if @tasks.empty?
                  break unless @workers.find{|x| x.status == :running }
                else
                  worker.run(@tasks.shift, type)
                end</code></pre></figure>

<p>okay コマンドと ready コマンドの動作を説明します。</p>

<p>ready は、ファイルの実行が終了し再びコマンドの待ち受けに入ったことを意味します。
まだ実行していないファイルがあるときは Worker#run に渡して実行します。</p>

<p>まだ実行していないファイルもなく、かつ全ての worker が実行中でなければ、ループを抜けてファイナライズに入ります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              when /^done (.+?)$/
                r = Marshal.load($1.unpack("m")[0])
                result &lt;&lt; r[0..1]
                rep    &lt;&lt; {file: worker.real_file,
                           report: r[2], result: r[3], testcase: r[5]}
                $:.push(*r[4]).uniq!</code></pre></figure>

<p>done コマンドでは、worker から返されたテスト数 (test_foobar のようなメソッドの数) とアサーション数を結果に加えています。</p>

<p>また、リトライ用の情報を別の配列に加えています。</p>

<p>そしてロードパスに差分を加えてから、重複防止のため Array#uniq! しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              when /^p (.+?)$/
                print $1.unpack("m")[0]</code></pre></figure>

<p>p コマンドはただ出力するだけですので unpack した文字列を print しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              when /^after (.+?)$/
                @warnings &lt;&lt; Marshal.load($1.unpack("m")[0])</code></pre></figure>

<p>after コマンドでは渡された例外を配列に加えているだけです。</p>

<p>LoadError などを受け取って、テストの結果出力の前にまとめて配列に入っている例外を出力します。</p>

<p>たとえば psych<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> のテストファイルを require すると、libyaml<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup> がない環境では LoadError が出るため、それを見失わないよう最後に出力しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              when /^bye (.+?)$/
                after_worker_down worker, Marshal.load($1.unpack("m")[0])</code></pre></figure>

<p>bye コマンドに base64 でエンコードされた文字列がついていた場合には異常終了を表しているため、異常終了時に呼ぶ after_worker_down メソッドを呼びます。
これが呼ばれると異常終了としてその例外を出力し、テスト全体の実行が中断されます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              when /^bye$/
                if shutting_down
                  after_worker_quit worker
                else
                  after_worker_down worker
                end</code></pre></figure>

<p>bye コマンドは quit コマンドの直後にも返されるため、意図して bye コマンドが返ってきた場合は after_worker_quit() 、意図していない終了の場合は after_worker_down() を呼んでいます。</p>

<p>after_worker_quit では IO を close したりなどのファイナライズを行っています。</p>

<h4 id="リトライ機能">リトライ機能</h4>

<p>リトライ機能とは、worker で failure や error となったテストを master で実行し直す機能です。</p>

<p>残念ながら Ruby に付属するテストのすべてが並列動作に対応しているわけではなく、中には並列化に対応するのが困難なものもあります。
そのため、並列動作時に失敗したテストを、並列ではない状態で再実行させています。
これにより、テストを並列化に対応させる負担を減らしています。</p>

<p>再実行は master で行います。
これは、worker で実行すると失敗するテストも存在するので、なるべく従来の動作に合わせるためです。</p>

<p>lib/test/unit.rb:490 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          if @interrupt || @opts[:no_retry] || @need_quit
            rep.each do |r|
              report.push(*r[:report])
            end
            @errors += rep.map{|x| x[:result][0] }.inject(:+)
            @failures += rep.map{|x| x[:result][1] }.inject(:+)
            @skips += rep.map{|x| x[:result][2] }.inject(:+)</code></pre></figure>

<p>もし ^C などでの途中中断や、–no-retry オプションが指定された場合はリトライをしません。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          else
            puts ""
            puts "Retrying..."
            puts ""
            @options = @opts
            rep.each do |r|
              if r[:testcase] &amp;&amp; r[:file] &amp;&amp; !r[:report].empty?
                require r[:file]
                _run_suite(eval(r[:testcase]),type)
              else
                report.push(*r[:report])
                @errors += r[:result][0]
                @failures += r[:result][1]
                @skips += r[:result][2]
              end
            end
          end</code></pre></figure>

<p>リトライするのは Module#name で名前が取得できたテストケースのみです。</p>

<h4 id="testunitrunnerworker-クラス">Test::Unit::Runner::Worker クラス</h4>

<p>Test::Unit::Runner::Worker クラス (以下 Worker クラス) で、worker プロセスを抽象化しています。</p>

<p>Worker クラスでは、以下の作業をメソッド化しています。</p>

<ul>
  <li>worker プロセスの起動</li>
  <li>worker プロセスとの送受信</li>
  <li>worker プロセスへ run コマンドの送信</li>
</ul>

<h5 id="worker-プロセスの起動">worker プロセスの起動</h5>

<p>Worker.launch(ruby,args=[]) で worker プロセスを新たにひとつ起動して Worker クラスのオブジェクトを返します。 ruby に配列で ruby へのパスとその起動オプションを指定します。</p>

<p>lib/test/unit.rb:233 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        def self.launch(ruby,args=[])
          io = IO.popen([*ruby,
                        "#{File.dirname(__FILE__)}/unit/parallel.rb",
                        *args], "rb+")
          new(io: io, pid: io.pid, status: :waiting)
        end</code></pre></figure>

<p>やっていることは簡単で、IO.popen でプロセスを起動し、その情報を Worker.new に渡してオブジェクトを返しています。</p>

<h5 id="worker-プロセスとの送受信">worker プロセスとの送受信</h5>

<p>Worker#puts と Worker#read が担当しています。</p>

<p>lib/test/unit.rb:250 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        def puts(*args)
          @io.puts(*args)
        end</code></pre></figure>

<p>シンプルに IO#puts に渡しています。</p>

<p>lib/test/unit.rb:276 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        def read
          res = (@status == :quit) ? @io.read : @io.gets
          res &amp;&amp; res.chomp
        end</code></pre></figure>

<p>これはちょっと複雑です。もし worker が終了しているなら IO#read 、していないなら IO#gets を読んでいます。</p>

<p>そして返り値は nil か String#chomp された String かになっています。</p>

<h5 id="worker-プロセスへ-run-コマンドの送信">worker プロセスへ run コマンドの送信</h5>

<p>Worker#run(task,type) にファイル名とタイプを渡すことで run コマンドを送信してくれます。</p>

<p>lib/test/unit.rb:254 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        def run(task,type)
          @file = File.basename(task).gsub(/\.rb/,"")
          @real_file = task</code></pre></figure>

<p>–jobs-status オプションの処理と done コマンド受信時の動作用に、ファイル名をインスタンス変数に保管しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          begin
            puts "loadpath #{[Marshal.dump($:-@loadpath)].pack("m").gsub("\n","")}"
            @loadpath = $:.dup</code></pre></figure>

<p>ロードパスの差分を送信し、将来また差分を取るために現時点のロードパスを複製して保管しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">            puts "run #{task} #{type}"
            @status = :prepare</code></pre></figure>

<p>run コマンドを送信し、ステータスを prepare に変更しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          rescue Errno::EPIPE
            dead
          rescue IOError
            raise unless ["stream closed","closed stream"].include? $!.message
            dead
          end
        end</code></pre></figure>

<p>例外処理です。終了していた場合は dead メソッドを呼んで IO の close などをしています。</p>

<h3 id="worker-の実装">worker の実装</h3>

<p>worker の実装は lib/test/unit/parallel.rb になります。
master は parallel.rb を worker として起動します。</p>

<p>parallel.rb は主に以下のことを行います。</p>

<ul>
  <li>master からファイル名を受け取ったらそれを require して中のテストケースを実行</li>
  <li>テストケース実行時の出力を master に送信</li>
</ul>

<p>以下、詳細です。</p>

<h4 id="おまじない">おまじない</h4>

<p>lib/test/unit/parallel.rb:77 から</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        Signal.trap(:INT,"IGNORE")</code></pre></figure>

<p>^C でテストを中断すると子プロセスにも SIGINT が伝播してしまいますが、master の管理外で勝手に worker が終了すると迷惑なので、無視するようにしています。</p>

<p>また lib/test/unit/parallel.rb:80 から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          @stdout = increment_io(STDOUT)
          @stdin = increment_io(STDIN)</code></pre></figure>

<p>STDIN と STDOUT は一部のテストケースが改変するので、@stdin と @stdout に dup してバックアップしてあります。</p>

<h4 id="master-からのコマンド受付">master からのコマンド受付</h4>

<p>lib/test/unit/parallel.rb:84 行目から抜粋</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">          while buf = @stdin.gets
            case buf.chomp
            when /^loadpath (.+?)$/
              @old_loadpath = $:.dup
              $:.push(*Marshal.load($1.unpack("m")[0].force_encoding("ASCII-8BIT"))).uniq!</code></pre></figure>

<p>ロードパスの差分を受け取ってロードパスに加えます。
このとき、重複防止のために Array#uniq! を呼んでいます。</p>

<p>@old_loadpath はテストケース実行後にロードパスの差分を取るために使用されます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">            when /^run (.+?) (.+?)$/
              @stdout.puts "okay"</code></pre></figure>

<p>run コマンドを受け取ってまずは okay コマンドを返します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              @options = @opts.dup
              suites = MiniTest::Unit::TestCase.test_suites</code></pre></figure>

<p>追加されたテストケースを確認するために Minitest::Unit::TestCase.test_suites を保持しておきます。</p>

<p>Minitest::Unit::TestCase.test_suites は毎回別のオブジェクトを返すので、Object#dup する必要はありません。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              begin
                require $1
              rescue LoadError
                @stdout.puts "after #{[Marshal.dump([$1, $!])].pack("m").gsub("\n","")}"
                @stdout.puts "ready"
                next
              end</code></pre></figure>

<p>require して LoadError が起こった場合、after コマンドでその事を master に伝え、再度コマンド待ち受け状態に戻ります。
LoadError は、たとえば libyaml がないときに psych ライブラリのテストを require したときなどに起こります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">              _run_suites MiniTest::Unit::TestCase.test_suites-suites, $2.to_sym
              @stdout.puts "ready"</code></pre></figure>

<p>問題がなければテストケースを渡して実行します。</p>

<p>実行が終わったら ready コマンドを送信し、コマンドの待ち受け状態に戻ります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">            when /^quit$/
              begin
                @stdout.puts "bye"
              rescue Errno::EPIPE; end
              exit</code></pre></figure>

<p>quit コマンドを受信した場合、bye コマンドを返し終了します。</p>

<h4 id="テストの実行">テストの実行</h4>

<p>_run_suite メソッドがテストケースを実行します。
本来のテストケースの実行に _run_suite が使われるので、orig_run_suite にリネームしています。</p>

<p>lib/test/unit/parallel.rb:27 から</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">      def _run_suite(suite, type)
        r = report.dup
        orig_stdout = MiniTest::Unit.output
        i,o = IO.pipe
        MiniTest::Unit.output = o</code></pre></figure>

<p>MiniTest::Unit のテスト結果出力先を保持し、IO.pipe にバイパスするように変更しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        th = Thread.new do
          begin
            while buf = (self.verbose ? i.gets : i.read(5))
              @stdout.puts "p #{[buf].pack("m").gsub("\n","")}"
            end
          rescue IOError
          rescue Errno::EPIPE
          end
        end</code></pre></figure>

<p>テスト実行中にその出力を取得し、master に送信するためのスレッドです。
-v が指定された場合は1行ごと、-v でない場合は 5 バイトごとに出力するようにしています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        e, f, s = @errors, @failures, @skips

        result = orig_run_suite(suite, type)

        MiniTest::Unit.output = orig_stdout</code></pre></figure>

<p>error と failure と skip の個数を、差分の取得に使うために保管してから、テストを実行します。</p>

<p>orig_run_suite はテストのメソッド数とアサーション数の配列を返してきます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        o.close
        begin
          th.join
        rescue IOError
          raise unless ["stream closed","closed stream"].include? $!.message
        end
        i.close</code></pre></figure>

<p>テスト結果の出力を master に通知するスレッドを停止させています。
o.close すると i に EOF が入るので、自然に終了するかまたは例外が発生するのを待ちます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        result &lt;&lt; (report - r)
        result &lt;&lt; [@errors-e,@failures-f,@skips-s]
        result &lt;&lt; ($: - @old_loadpath)
        result &lt;&lt; suite.name</code></pre></figure>

<p>ここでは error や failure のメッセージ、error と failure と skip の数、ロードパスの差分、テストケース名を result に挿入しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">        begin
          @stdout.puts "done #{[Marshal.dump(result)].pack("m").gsub("\n","")}"
        rescue Errno::EPIPE; end
        return result</code></pre></figure>

<p>done を出力して result を返します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">      ensure
        MiniTest::Unit.output = orig_stdout
        o.close if o &amp;&amp; !o.closed?
        i.close if i &amp;&amp; !i.closed?
      end</code></pre></figure>

<p>ensure 文で元の出力先へ確実に戻し、IO.pipe で開いた IO オブジェクトを close しています。</p>

<h3 id="test-の並列実行への対応">test/* の並列実行への対応</h3>

<p>前述したように、すべてのテストが並列動作に対応しているわけではありません。
一部のテストは並列で動かすと failure もしくは error となります。</p>

<p>うまく動作しないテストのうち、その原因が分かったものは並列でも正しく動作するよう修正しました。</p>

<p>以下に、うまく動作しなかったテストとその原因を紹介します。</p>

<h4 id="testrubytest_signalrb">test/ruby/test_signal.rb</h4>

<p>ここではテストではなく test/unit を修正しています。</p>

<p>このテストでは have_fork? で fork が使えるかを調べるときに、Test::Unit::Runner の at_exit が実行されてしまって若干表示が崩れます。</p>

<p>そのため、at_exit 実行時にフラグを見て、true のときは実行しないように変更しました。</p>

<h4 id="testrubytest_processrb">test/ruby/test_process.rb</h4>

<p>このテストは STDIN と STDOUT を改変するため、並列で動作しませんでした。</p>

<p>そのため、Test::Unit::Worker 側で STDIN とSTDOUT を dup してバックアップを保持するように変更しました。</p>

<h4 id="testnettest_httpsrb-test_httprb">test/net/test_https.rb, test_http.rb</h4>

<p>これらのテストでは同じ番号のポートを使っていたため、並列で動作しませんでした。</p>

<p>そのため、ポート番号を変更して並列動作時に重複しないようにしました<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>。</p>

<h4 id="testcsv">test/csv</h4>

<p>このテストでは複数のテストケースが同じディレクトリを使っていて、他のテストケースが teardown でディレクトリを消去するためにエラーが発生していました。</p>

<p>そのため、テストケースごとにディレクトリ名を変更することで対処しました。</p>

<h2 id="結果">結果</h2>

<p>並列化の結果、どれくらいテスト全体が高速化したかのグラフを作成しました。</p>

<p>データは Ruby コミッタの一員である mrkn 氏に計測していただきました。
この場を借りてお礼を申し上げます。</p>

<h3 id="環境">環境</h3>

<table>
  <thead>
    <tr>
      <th>OS</th>
      <th>Mac OS X 10.6.6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU</td>
      <td>Intel Core i7 2.66 GHz (Dual Core)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>Memory</td>
      <td>8GB 1067 MHz DDR3</td>
    </tr>
  </tbody>
</table>

<h3 id="データ">データ</h3>

<table>
  <thead>
    <tr>
      <th>-j</th>
      <th>TOTAL</th>
      <th>TESTCASES</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>no -j</td>
      <td>121.490313</td>
      <td>120.7227436</td>
    </tr>
    <tr>
      <td>-j 1</td>
      <td>124.2141424</td>
      <td>124.1761476</td>
    </tr>
    <tr>
      <td>-j 2</td>
      <td>79.8405502</td>
      <td>79.79634</td>
    </tr>
    <tr>
      <td>-j 3</td>
      <td>64.6310893333333</td>
      <td>64.58236</td>
    </tr>
    <tr>
      <td>-j 5</td>
      <td>43.4185176</td>
      <td>43.36833</td>
    </tr>
    <tr>
      <td>-j 8</td>
      <td>44.394446</td>
      <td>44.3584944</td>
    </tr>
    <tr>
      <td>-j 13</td>
      <td>44.6113974</td>
      <td>44.5743406</td>
    </tr>
  </tbody>
</table>

<p>ここで「no -j」は -j をつけずに実行した場合 (従来の動作)、「TOTAL」は time コマンドで計測した real の値、「TESTCASES」は test/unit が出力した Finished test… の値を表します。
また単位は秒です。</p>

<h3 id="グラフ">グラフ</h3>

<p>図2. 時間と比率のグラフ
<img src="/images/0033-ParallelizeTestAll/graph.png" alt="graph.png" /></p>

<h3 id="考察">考察</h3>

<p>並列動作させると、最大で約 2.7 倍の速度向上がみられました。
並列化によって高い効果が得られたことがわかります。</p>

<p>今回はデュアルコアの CPU で計測しましたが、worker 数が 5 のときに最大の効果が得られました。
デュアルコアの CPU でもこれほどの効果が得られるのですから、最近のクアッドコアあるいはそれ以上の CPU であれば、さらに効果が得られると思います。</p>

<h2 id="実際に使用する">実際に使用する</h2>

<p>今回の並列化機能は Ruby の trunk ブランチに取り込まれているため、trunk を取得すれば使用できます。
Ruby の anonymous svn などから trunk を取得・ビルドし、以下のコマンドを入力してみてください (ビルド方法や trunk の取得方法などは割愛します)。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">make TESTS='-v -j4' test-all</code></pre></figure>

<p>この場合なら、4 つの worker を起動して test-all を並列に実行します。</p>

<p>並列に実行されていることは、ログを見れば確認できます。
ログを見ると、通常はテストケースが 1 つずつ順番に実行されますが、-j オプションを有効にすると複数のテストケースがログに同時に現れるため、並列に実行されていることがわかります。</p>

<p>なお今回説明した並列化の機能は、test-all に限らず一般の Ruby プロジェクトでも使用できます。
現在 test/unit を使っていて複数のテストケースを実行しているなら、並列化のオプションを引数に加えることで、高速化の恩恵を受けることができるでしょう。</p>

<h2 id="協力のおねがい">協力のおねがい</h2>

<p>今回説明した機能は開発途中であり、一部のプラットフォームではまだ動作しません。動作しても安定しない場合があります。
その場合はログなどを添えて、<a href="http://redmine.ruby-lang.org">Ruby バグトラッカー (Redmine)</a> までご報告ください。
パッチもあるとなお良いです。</p>

<p>特に Windows では現時点でうまく動きません (test_process などでフリーズします)。
Windows で動くようにしてくれるパッチは歓迎いたします。</p>

<h2 id="謝辞">謝辞</h2>

<p>mrkn 氏には、アドバイスやデータ計測などでご協力いただきました。
また、ruby コミッターの皆様にもアドバイス等を IRC で頂きました。
この場を借りてお礼申し上げます。ありがとうございました。</p>

<h2 id="あとがき">あとがき</h2>

<p>短いですが、おおまかに parallel_test の実装を解説しました。</p>

<p>これからもこの機能がさらに安定して動作するように改良を続けていく所存です。
パッチなどは喜んで受け付けるので気軽にお願いします。</p>

<p>では。</p>

<p>2011年3月 こたつにて</p>

<h2 id="著者について">著者について</h2>

<p>Shota Fukumori (sora_h)。
小学六年から Rubyist、中二で最年少 Ruby コミッタ、この記事が公開されるころには中三の予定。
また「Ruby の C 実装を一番知らないコミッタ」3 代目を襲名。
iOS アプリなどを作っているのでよければ買ってください (<a href="http://itunes.apple.com/jp/app/bm-wifi-info/id410107488">http://itunes.apple.com/jp/app/bm-wifi-info/id410107488</a> とか)。</p>

<p>Twitter: <a href="http://twitter.com/sora_h">@sora_h</a>、Profile: <a href="http://sorah.cosmio.net/">http://sorah.cosmio.net/</a>、Blog: <a href="http://codnote.net/">http://codnote.net/</a></p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>記事執筆時点。公開時点では厨三にバージョンアップしています。&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>編集部注:「r31140」とはリビジョン 31140 のことです。コミット日は 2011 年 3 月 21 日です。&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>編集部注:「ruby-dev」とは Ruby 開発者用メーリングリストのことです。&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>編集部注:「r30939」とはリビジョン 30939 のことです。コミット日は 2011 年 2 月 22 日。&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>編集部注:「psych」は Ruby 1.9.2 から標準搭載された YAML ライブラリです。利用するには libyaml が必要です。&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>編集部注:「libyaml」は C 言語で実装された YAML ライブラリです。その Ruby 用バインディングが psych です。&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>パッチを提出する前に IRC に書いていたら先に他の方にコミットされていたので、筆者の修正には入っていませんが。&nbsp;<a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

            </div>
        </div>
    </div>
  </body>
</html>
<!DOCTYPE html>
<html>
