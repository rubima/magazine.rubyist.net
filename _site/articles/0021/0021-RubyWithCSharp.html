<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C# と Ruby を連携させる</title>
  <meta name="description" content="書いた人：星一">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/css/theme.css" rel="stylesheet" type="text/css">
  <link href="/css/syntax.css" rel="stylesheet" type="text/css">

  <link rel="canonical" href="http://magazine.rubyist.net/articles/0021/0021-RubyWithCSharp.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="http://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="/images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="/articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="/articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="/articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="/articles/pretokyorubykaigi11/preTokyoRubyKaigi11.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="/articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="/articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="/articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="/articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="/articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="/articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="/articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="/articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="/articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="/articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="/articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="/articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="/articles/ruby200specialen/Ruby200SpecialEn.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="/articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="/articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="/articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="/articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="/articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="/articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="/articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="/articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="/articles/prerubykaigi2011/preRubyKaigi2011.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="/articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="/articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="/articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="/articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="/articles/prerubykaigi2010/preRubyKaigi2010.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="/articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="/articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="/articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="/articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="/articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="/articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="/articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="/articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="/articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="/articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="/articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="/articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="/articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="/articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="/articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="/articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="/articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="/articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="/articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="/articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="/articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="/articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="/articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="/articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="/articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="/articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="/articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="/articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="/articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="/articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="/articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="/images/rubima_logo_l.png">
                        <h1>C# と Ruby を連携させる</h1>
                        <div class="social-buttons">
                            <a href="http://b.hatena.ne.jp/entry//articles/0021/0021-RubyWithCSharp.html" class="hatena-bookmark-button" data-hatena-bookmark-title="C# と Ruby を連携させる" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<span id="fb-root"></span>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.5";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<span class="fb-like" data-href="/articles/0021/0021-RubyWithCSharp.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></span>
<a href="https://twitter.com/share" class="twitter-share-button" data-url="/articles/0021/0021-RubyWithCSharp.html" data-text="C# と Ruby を連携させる">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                        </div>
                        <p>書いた人：星一</p>

<ul id="markdown-toc">
  <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a>    <ul>
      <li><a href="#前提知識" id="markdown-toc-前提知識">前提知識</a></li>
      <li><a href="#その他" id="markdown-toc-その他">その他</a></li>
    </ul>
  </li>
  <li><a href="#背景" id="markdown-toc-背景">背景</a></li>
  <li><a href="#準備" id="markdown-toc-準備">準備</a>    <ul>
      <li><a href="#visual-c-express-で新しいプロジェクトを作る" id="markdown-toc-visual-c-express-で新しいプロジェクトを作る">Visual C# Express で新しいプロジェクトを作る</a></li>
      <li><a href="#ruby-の-dll-を手に入れる" id="markdown-toc-ruby-の-dll-を手に入れる">Ruby の DLL を手に入れる</a></li>
      <li><a href="#プロジェクトに-dll-を追加する" id="markdown-toc-プロジェクトに-dll-を追加する">プロジェクトに DLL を追加する</a></li>
    </ul>
  </li>
  <li><a href="#ファイルに出力-hello-world" id="markdown-toc-ファイルに出力-hello-world">ファイルに出力 (Hello, World)</a>    <ul>
      <li><a href="#ポーティング" id="markdown-toc-ポーティング">ポーティング</a></li>
      <li><a href="#ファイルに出力してみる" id="markdown-toc-ファイルに出力してみる">ファイルに出力してみる</a></li>
    </ul>
  </li>
  <li><a href="#標準出力" id="markdown-toc-標準出力">標準出力</a>    <ul>
      <li><a href="#c-による-ruby-の定数の定義" id="markdown-toc-c-による-ruby-の定数の定義">C# による Ruby の定数の定義</a></li>
      <li><a href="#ruby-文字列--c-文字列" id="markdown-toc-ruby-文字列--c-文字列">Ruby 文字列 → C# 文字列</a></li>
      <li><a href="#c-による-ruby-のメソッド定義" id="markdown-toc-c-による-ruby-のメソッド定義">C# による Ruby のメソッド定義</a></li>
      <li><a href="#いよいよ標準出力" id="markdown-toc-いよいよ標準出力">いよいよ標準出力</a></li>
    </ul>
  </li>
  <li><a href="#もっと-c-と-ruby-を連携させる" id="markdown-toc-もっと-c-と-ruby-を連携させる">もっと C# と Ruby を連携させる</a>    <ul>
      <li><a href="#数値変換" id="markdown-toc-数値変換">数値変換</a>        <ul>
          <li><a href="#ruby-整数値--c-整数値" id="markdown-toc-ruby-整数値--c-整数値">Ruby 整数値 → C# 整数値</a></li>
          <li><a href="#c-整数値--ruby-整数値" id="markdown-toc-c-整数値--ruby-整数値">C# 整数値 → Ruby 整数値</a></li>
        </ul>
      </li>
      <li><a href="#文字列変換" id="markdown-toc-文字列変換">文字列変換</a>        <ul>
          <li><a href="#ruby-文字列--c-文字列-1" id="markdown-toc-ruby-文字列--c-文字列-1">Ruby 文字列 → C# 文字列</a></li>
          <li><a href="#c-文字列--ruby-文字列" id="markdown-toc-c-文字列--ruby-文字列">C# 文字列 → Ruby 文字列</a></li>
        </ul>
      </li>
      <li><a href="#c-から-ruby-のメソッド呼び出し" id="markdown-toc-c-から-ruby-のメソッド呼び出し">C# から Ruby のメソッド呼び出し</a></li>
      <li><a href="#c-による-ruby-のクラス定義" id="markdown-toc-c-による-ruby-のクラス定義">C# による Ruby のクラス定義</a></li>
    </ul>
  </li>
  <li><a href="#問題点" id="markdown-toc-問題点">問題点</a>    <ul>
      <li><a href="#実行環境が限定される" id="markdown-toc-実行環境が限定される">実行環境が限定される</a></li>
      <li><a href="#cc-のデータ変換はコストがかかる" id="markdown-toc-cc-のデータ変換はコストがかかる">C/C# のデータ変換はコストがかかる</a></li>
      <li><a href="#gc-が独立して動いてしまう" id="markdown-toc-gc-が独立して動いてしまう">GC が独立して動いてしまう</a></li>
    </ul>
  </li>
  <li><a href="#おわりに" id="markdown-toc-おわりに">おわりに</a></li>
  <li><a href="#宣伝" id="markdown-toc-宣伝">宣伝</a></li>
  <li><a href="#謝辞" id="markdown-toc-謝辞">謝辞</a></li>
  <li><a href="#書いた人" id="markdown-toc-書いた人">書いた人</a></li>
</ul>

<h2 id="はじめに">はじめに</h2>

<p>C# と Ruby を連携させるための (バッド) ノウハウを解説します。 Ruby から .NET の機能を呼び出したりすることが出来ます。</p>

<p>巷では、 IronRuby とか DLR とか色々話題になっていますが、今回の方法はそんなの関係ありません。 IronRuby は絶賛開発中ですが、ここで扱う方法は MatzRuby そのものを使うため、 Ruby の機能を制限なく活用しつつ、今すぐ試すことができます。ただし、拡張ライブラリのようなものが作れるわけではなく、閉じた環境でしか実行できないものになります。</p>

<h3 id="前提知識">前提知識</h3>

<ul>
  <li>C# の匿名デリゲートが分かる程度</li>
  <li>組み込み Ruby の基本的なことが分かる程度</li>
</ul>

<h3 id="その他">その他</h3>

<p>ここで扱う方法は忘れて、将来は素直に IronRuby を使ったほうがいいと思います。</p>

<h2 id="背景">背景</h2>

<ol>
  <li>C# (.NET) には、 P/Invoke という、 C で書かれた DLL などの関数を呼び出せる機能がある</li>
  <li>Ruby (Matz Ruby) は C で書かれている</li>
  <li>しかも、 Ruby の機能をいじくる C のインターフェイスがとっても扱いやすい</li>
  <li>C# で Ruby の DLL の関数呼べばなんでもできるね</li>
</ol>

<p>というわけで、 C# で C の関数を呼び出して実行するのがメインになります。</p>

<h2 id="準備">準備</h2>

<p>以下のものを準備します。</p>

<ul>
  <li><a href="http://www.microsoft.com/japan/msdn/vstudio/express/vcsharp/">Visual C# 2005 Express</a></li>
  <li>msvcrt-ruby18.dll (後述)</li>
</ul>

<p>今回は Windows でのみ動作確認を行いました。 Linux でも <a href="http://www.mono-project.com/">Mono</a> を使えば出来るかもしれません。</p>

<h3 id="visual-c-express-で新しいプロジェクトを作る">Visual C# Express で新しいプロジェクトを作る</h3>

<p>今回はコンソールアプリケーションで説明します。</p>

<p>名前は別に何でもいいです。ここでは「RubyTest」というプロジェクト名、名前空間であるとして説明します。</p>

<h3 id="ruby-の-dll-を手に入れる">Ruby の DLL を手に入れる</h3>

<p>Windows 用の Ruby のライブラリを手に入れます。 mswin32 版でも cygwin 版でも mingw 版でも、どれでも OK なはずです<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>今回は <a href="http://www.garbagecollect.jp/ruby/mswin32/ja/">mswin32 版</a>の、 1.8.x 系統を使います<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</p>

<h3 id="プロジェクトに-dll-を追加する">プロジェクトに DLL を追加する</h3>

<p>下図のように、 DLL を追加してやります。
<img src="/images/0021-RubyWithCSharp/project_tree.png" alt="project_tree.png" /></p>

<p>さらに DLL の「出力ディレクトリにコピー」プロパティを「常にコピーする」に設定します。
<img src="/images/0021-RubyWithCSharp/dll_property.png" alt="dll_property.png" /></p>

<p>参照の設定は要りません。</p>

<p>現在 Ruby 1.8.x の、 64bit Windows 向けのバイナリは存在しません。そのため、そのまま C# をコンパイルしてしまうと、 DLL の関数呼び出し時に例外 (BadImageFormatException) が投げられます。デフォルトでは、 C# のコンパイルのターゲットは “Any CPU” となっており、 C の DLL と連携する際、想定する DLL の形式が実行環境依存になってしまうからです。 64 bit 版の Windows で試す場合は、 C# コンパイルのターゲットを 32 bit (x86) 用にして、 32 bit 互換モードで実行させてやる必要があります。</p>

<p>Visual C# Express の場合、</p>

<ol>
  <li>「ツール」→「オプション」を開く</li>
  <li>左下隅の「すべての設定を表示」にチェックを入れる</li>
  <li>「プロジェクトおよびソリューション」→「全般」の「ビルド構成の詳細を表示」にチェックを入れる</li>
</ol>

<p>という手順でビルドの詳細が設定できるようになり、ターゲットを設定することが出来るようになります。</p>

<h2 id="ファイルに出力-hello-world">ファイルに出力 (Hello, World)</h2>

<p>Ruby の Hello, World のスクリプトを、 C# から実行させましょう。標準出力 (コンソールに出力) はまだできないので、ファイルに出力します。</p>

<h3 id="ポーティング">ポーティング</h3>

<p>Ruby の DLL で定義されている関数を、 C# で使えるように「ポーティング」してあげます。説明するのがだるいので、実例をさっさと挙げてしまいます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using System;
using System.Collections.Generic;
using System.Runtime.InteropServices; // (1)
using System.Text;
using VALUE = System.Int32; // (2)

namespace RubyTest
{
    static class Ruby
    {
        public const string RubyDll = "msvcrt-ruby18"; // (3)

        [DllImport(RubyDll)]
        public static extern void ruby_init(); // (4)

        [DllImport(RubyDll)]
        public static extern VALUE rb_eval_string_protect(byte[] script, ref VALUE state); // (5)

        public static VALUE rb_eval_string_protect(string script, ref state) // (6)
        {
            return rb_eval_string_protect(Encoding.UTF8.GetBytes(script + '\0'), ref state);
        }
    }
}</code></pre></figure>

<p>(1): DllImportAttribute を使用するための using です。 DllImportAttribute 属性はメソッドに付加する属性で、外部 DLL で定義されていることを表します。</p>

<p>(2): VALUE は、 Ruby のオブジェクトを一意に表す整数型です。整数型や nil などの特殊な値を除いて、ポインタの値そのものです。</p>

<p>今回使用する Ruby の DLL では VALUE は 32 bit 整数型 (のはず) であり、 C# では int (System.Int32) と同じです。ソースコード上で、 C# の int と、 VALUE の意味での int が混合するのは紛らわしいので、 (2) のようにエイリアスを作ってやります。</p>

<p>(3): DLL のパスを表す文字列定数です。拡張子は要りません。</p>

<p>以下、必要最小限の関数だけ定義してやります。</p>

<p>(4): C で定義された ruby_init() を C# で使う場合、このように記述します。 extern は C# の予約語です。この関数は引数がなく、返り値の型 void なので非常に素直に書けます。こんなのばかりだといいのですが、そういうわけには行きませんね。</p>

<p>(5): rb_eval_string_protect(char *script, int *state) 関数のポーティングです。この関数は、文字列の script を Ruby スクリプトとして評価します。例外発生時に、 state が NULL でない場合に例外オブジェクトの VALUE 値が代入されます。戻り値は評価された Ruby オブジェクトをあらわす VALUE です。</p>

<p>protect のつかない、 rb_eval_string 関数は今回は使いませんでした。 rb_eval_string 関数を使用した場合、スクリプト評価時に例外が発生すると、 C# 側で予期せぬエラーが生じるからです。</p>

<p>C で定義された関数を C# から呼び出すために、 .NET の「マーシャリング」を利用します。マーシャリングとは、 .NET の型とネイティブ型を相互変換する機能です。 C の型と C# (.NET) の型には一定のルールがあり<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>、非常に複雑ですが、適当に抜粋すると以下のようになります。</p>

<table>
  <thead>
    <tr>
      <th>C</th>
      <th>C#</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>char</td>
      <td>byte</td>
    </tr>
    <tr>
      <td>32 bit 整数</td>
      <td>int</td>
    </tr>
    <tr>
      <td>64 bit 整数</td>
      <td>long</td>
    </tr>
    <tr>
      <td>float</td>
      <td>float</td>
    </tr>
    <tr>
      <td>double</td>
      <td>double</td>
    </tr>
    <tr>
      <td>ポインタ</td>
      <td>ポインタ</td>
    </tr>
    <tr>
      <td>ポインタ</td>
      <td>IntPtr 構造体</td>
    </tr>
    <tr>
      <td>ポインタ</td>
      <td>参照渡し (ref)</td>
    </tr>
    <tr>
      <td>ポインタ</td>
      <td>配列</td>
    </tr>
    <tr>
      <td>char ポインタ</td>
      <td>string</td>
    </tr>
    <tr>
      <td>関数ポインタ</td>
      <td>デリゲート</td>
    </tr>
  </tbody>
</table>

<p>今回、 char* を byte[] 型にしました。文字コードに自由を効かせたいためです。</p>

<p>「マーシャリング」という言葉は Ruby の Marshal と紛らわしいので、以後「C/C# のデータ変換」と呼びます。</p>

<p>(6): バイトの配列を引数に取るのはちょいと使いづらいので、文字列を引数に取るバージョンを定義してあげます。</p>

<p>C# の string から byte[] にする際、文字列の最後にナルバイトを付加しています。</p>

<h3 id="ファイルに出力してみる">ファイルに出力してみる</h3>

<p>さっそく “Hello, World!” を出力するプログラムを書いてみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using System;
using System.Collections.Generic;
using System.Text;

namespace RubyTest
{
    class Program
    {
        static void Main(string[] args)
        {
            VALUE state = 0;

            Ruby.ruby_init();
            Ruby.rb_eval_string_protect("open('hello.txt', 'w') {|fp| fp.write(\"Hello, World!\\n\")}", ref state);
        }
    }
}</code></pre></figure>

<p>“Hello, World!” と書かれた hello.txt ファイルが生成されていれば成功です。</p>

<p>標準入力をコンソールに出すためには色々面倒な手順が必要なので、後ほど解説します。</p>

<h2 id="標準出力">標準出力</h2>

<p>標準出力をコンソールに出すまでの手順を紹介します。</p>

<h3 id="c-による-ruby-の定数の定義">C# による Ruby の定数の定義</h3>

<p>Qnil などの定数を逐一 C# で定義してやる必要があります。全部定義するのは非常に面倒なので、よく使うものだけ定義しておきましょう。必要になったら付け足せばよいのです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    public const VALUE Qfalse = (VALUE)0;
    public const VALUE Qtrue = (VALUE)2;
    public const VALUE Qnil = (VALUE)4;

    // 略
}</code></pre></figure>

<p>上から順に、 false、 true、 nil を表す値です。</p>

<p>Ruby の型を使って C# 上でごにょごにょやりたい場合は、 T_* 系の定数も定義する必要があります。ここでは割愛します。</p>

<p>VALUE も int も全く同じなので、キャストする必要は全然ないのですが、見やすくするために書いておきます。</p>

<h3 id="ruby-文字列--c-文字列">Ruby 文字列 → C# 文字列</h3>

<p>Ruby 文字列を C# 文字列に変換するための処理を書きます。 Ruby の関数 rb_string_value_cstr を使用します。ところで、 Ruby 文字列を C 文字列に変換する際には、は StringValuePtr マクロを使うのが普通なのですが、マクロは展開されてしまっているために C# で使用することはできません。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    [DllImport(RubyDll)]
    private static extern IntPtr rb_string_value_cstr(ref VALUE v_ptr); // (1)

    public static string StringValuePtr(VALUE v) // (2)
    {
        int length = 0;
        IntPtr ptr = rb_string_value_cstr(ref v); // (3)
        unsafe
        {
            byte* p = (byte*)ptr; // (4)
            while (*p != 0) // (5)
            {
                length++;
                p++;
            }
        }
        byte[] bytes = new byte[length];
        Marshal.Copy(ptr, bytes, 0, length); // (6)
        return Encoding.UTF8.GetString(bytes);
    }

    // 略
}</code></pre></figure>

<p>(1): rb_string_value_cstr 関数をポーティングします。この関数は、 Ruby の String オブジェクトの値 (VALUE) から C の文字列を取得します。引数は VALUE * 型であり、 C# では VALUE の参照型 (ref) とできます。返り値は char* 型であり、これは IntPtr 構造体型とします。 IntPtr は、プラットフォーム非依存な、ポインタのラッパーです。</p>

<p>(2): StringValuePtr メソッドを定義します。引数に Ruby の文字列の VALUE をとります。</p>

<p>(3): 内部で rb_string_value_cstr メソッドを使用し、文字列の char * なポインタを取得します。</p>

<p>(4): IntPtr を適当なポインタ型にキャストします。 1 バイト単位で操作するので、ここでは byte * にキャストします。</p>

<p>unsafe ブロックが必要なため、 unsafe が有効になるようにコンパイルしてください。プロジェクトのプロパティの「アンセーフ コードの許可」という項目で設定できるはずです。</p>

<p>(5): NULL バイトが出るまでループを回し、文字列の長さを取得します。 C# は条件式に bool 値しか書けないので、ちゃんと (不) 等式を書く必要があります。</p>

<p>(6): 最終的に、 IntPtr 型の値 (ptr) から指定した長さ分だけ、 byte の配列に変換します。</p>

<p>StringValuePtr メソッドを使う、必要最小限と思われるサンプルを次に書いてみました。コンソールに “hoge” と出力されれば成功です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using System;
using System.Collections.Generic;
using System.Text;
using VALUE = System.Int32;

namespace RubyTest
{
    class Program
    {
        static void Main(string[] args)
        {
            VALUE state = 0;

            Ruby.ruby_init();
            VALUE rbStr = Ruby.rb_eval_string_protect("'hoge'", ref state); // Ruby の文字列作成
            string csStr = Ruby.StringValuePtr(rbStr); // C# の文字列に変換
            Console.WriteLine(csStr);
            Console.ReadKey();
        }
    }
}</code></pre></figure>

<h3 id="c-による-ruby-のメソッド定義">C# による Ruby のメソッド定義</h3>

<p>Ruby のメソッドを定義するためのインターフェイスとして、以下のような関数が用意されています。</p>

<ul>
  <li>void rb_define_method(VALUE klass, const char <em>name, VALUE (</em>func)(), int argc);</li>
  <li>void rb_define_singleton_method(VALUE object, const char <em>name, VALUE (</em>func)(), int argc);</li>
</ul>

<p>rb_define_method は普通のインスタンスメソッドを定義します。 rb_define_singleton_method は特異メソッドを定義します。</p>

<p>argc は引数の数を表します。</p>

<p>まず、三番目の引数のためのデリゲートを作ります。 C の関数ポインタは引数の型があいまいですが、 C# のデリゲードの型は厳格なので、引数の個数が異なるものは別のデリゲートとして定義してやる必要があります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    public delegate VALUE CallbackArg0(VALUE self);
    public delegate VALUE CallbackArg1(VALUE self, VALUE arg1);
    public delegate VALUE CallbackArg2(VALUE self, VALUE arg1, VALUE arg2);

    // 略
}</code></pre></figure>

<p>引数の数はいくらでも定義できますが<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>、とりあえずこの程度にしておきます。</p>

<p>引数を見れば分かりますが、最初の値は self (メソッドのレシーバ) で、それ以降の引数が、実際のメソッドの引数となります。</p>

<p>次に、 rb_define_method および rb_define_singleton_method をポーティングします。 argc はデリゲートの型から判別できるため冗長なので、 C# から使う場合は省略できるようにしてしまいます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    private static List&lt;Delegate&gt; MethodDelegates = new List&lt;Delegate&gt;();

    [DllImport(RubyDll)]
    private static extern void rb_define_method(VALUE klass, string name, CallbackArg0 func, int argc);
    public static void rb_define_method(VALUE klass, string name, CallbackArg0 func)
    {
        MethodDelegates.Add(func);
        rb_define_method(klass, name, func, 0);
    }

    [DllImport(RubyDll)]
    private static extern void rb_define_method(VALUE klass, string name, CallbackArg1 func, int argc);
    public static void rb_define_method(VALUE klass, string name, CallbackArg1 func)
    {
        MethodDelegates.Add(func);
        rb_define_method(klass, name, func, 1);
    }

    [DllImport(RubyDll)]
    private static extern void rb_define_method(VALUE klass, string name, CallbackArg2 func, int argc);
    public static void rb_define_method(VALUE klass, string name, CallbackArg2 func)
    {
        MethodDelegates.Add(func);
        rb_define_method(klass, name, func, 2);
    }

    [DllImport(RubyDll)]
    private static extern void rb_define_singleton_method(VALUE obj, string name, CallbackArg0 func, int argc);
    public static void rb_define_singleton_method(VALUE obj, string name, CallbackArg0 func)
    {
        MethodDelegates.Add(func);
        rb_define_singleton_method(obj, name, func, 0);
    }

    [DllImport(RubyDll)]
    private static extern void rb_define_singleton_method(VALUE obj, string name, CallbackArg1 func, int argc);
    public static void rb_define_singleton_method(VALUE obj, string name, CallbackArg1 func)
    {
        MethodDelegates.Add(func);
        rb_define_singleton_method(obj, name, func, 1);
    }

    [DllImport(RubyDll)]
    private static extern void rb_define_singleton_method(VALUE obj, string name, CallbackArg2 func, int argc);
    public static void rb_define_singleton_method(VALUE obj, string name, CallbackArg2 func)
    {
        MethodDelegates.Add(func);
        rb_define_singleton_method(obj, name, func, 2);
    }

    // 略
}</code></pre></figure>

<p>上記ソースを見ていただければお分かりの通り、 C の関数を呼ぶ前にデリゲートを static なリスト (MethodDelegates) に保存しています。これはデリゲートが GC によって回収されてしまうのを防ぐためです。 C# (マネージド) のデリゲートは C (アンマネージド) では関数ポインタとなりますが、 C の関数ポインタをコールするときに、対応する C# のデリゲートが存在するかどうかは、 .NET のほうでちゃんと管理する必要があるのです。<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>。回収されてしまったデリゲートをコールしようとするとエラーになってしまいます。それを防ぐために、デリゲートへの static な参照を保持することにしました。</p>

<p>実際に使う例は、以下の通り。動作させるためには、プロジェクトの参照設定に “System.Windows.Forms” を追加する必要があります。  String クラスにメソッド “show_message” を定義してみました。 Ruby の文字列をダイアログボックスに表示してくれます。なんと日本語も OK です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using VALUE = System.Int32;

namespace RubyTest
{
    class Program
    {
        static void Main(string[] args)
        {
            VALUE state = 0;

            Ruby.ruby_init();
            VALUE rb_cString = Ruby.rb_eval_string_protect("String", ref state);
            Ruby.rb_define_method(rb_cString, "show_message", delegate(VALUE self)
            {
                MessageBox.Show(Ruby.StringValuePtr(self));
                return Ruby.Qnil;
            });
            Ruby.rb_eval_string_protect("'hoge'.show_message", ref state);
            Ruby.rb_eval_string_protect("'にほんご'.show_message", ref state);
        }
    }
}</code></pre></figure>

<h3 id="いよいよ標準出力">いよいよ標準出力</h3>

<p>いままで、 Ruby スクリプトで puts などの標準出力メソッドを使用しても、コンソールには何も出ませんでした。原因はよくわかりません。リファレンスによると<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>、Ruby では標準出力を変えるには「この変数 ($&gt;) の値を別の IO に再設定すればよい」ということが分かります。 $&gt; に代入されている値のデフォルト値は定数 STDOUT ですので、今回は STDOUT に write という特異メソッドを上書き定義してやることで、標準出力の挙動を変えることにします。</p>

<p>Ruby 風擬似コードを書くと、以下のようになります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">def STDOUT.write(str)
  (C# で Console.Write(str))
end</code></pre></figure>

<p>C# で書いてやると、次の通りになります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">VALUE rb_stdout = Ruby.rb_eval_string_protect("STDOUT", ref state);
Ruby.rb_define_singleton_method(rb_stdout, "write",
    delegate(VALUE self, VALUE rbStr)
    {
        Console.Write(Ruby.StringValuePtr(rbStr));
        return Ruby.Qnil;
    });</code></pre></figure>

<p>使用例は以下の通りです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using System;
using System.Collections.Generic;
using System.Text;
using VALUE = System.Int32;

namespace RubyTest
{
    class Program
    {
        static void Main(string[] args)
        {
            VALUE state = 0;

            Ruby.ruby_init();

            VALUE rb_stdout = Ruby.rb_eval_string_protect("STDOUT", ref state);
            Ruby.rb_define_singleton_method(rb_stdout, "write",
                delegate(VALUE self, VALUE rbStr)
                {
                    Console.Write(Ruby.StringValuePtr(rbStr));
                    return Ruby.Qnil;
                });

            Ruby.rb_eval_string_protect("puts 'Hello, World!'", ref state);
            Console.ReadKey();
        }
    }
}</code></pre></figure>

<p>これでやっとこさ標準出力がコンソールに出ました。おめでとうございます。</p>

<h2 id="もっと-c-と-ruby-を連携させる">もっと C# と Ruby を連携させる</h2>

<h3 id="数値変換">数値変換</h3>

<p>Fixnum の場合、シフト演算を使って DLL の関数を呼び出さずに済ませる方法があります。そのようにすると、 C/C# のデータ変換のコストがかからないので、処理が高速化されます。ここでは説明しません。</p>

<h4 id="ruby-整数値--c-整数値">Ruby 整数値 → C# 整数値</h4>

<p>rb_num2int 関数を使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    [DllImport(RubyDll)]
    private static extern int rb_num2int(VALUE val);

    public static int NUM2INT(VALUE val)
    {
        return rb_num2int(val);
    }

    // 略
}</code></pre></figure>

<p>マクロの NUM2INT という名前で使いたい! という理由だけでラッパーを作ってみたり。以下同様。</p>

<h4 id="c-整数値--ruby-整数値">C# 整数値 → Ruby 整数値</h4>

<p>rb_int2inum 関数を使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    [DllImport(RubyDll)]
    private static extern VALUE rb_int2inum(Int32 i);

    public static VALUE INT2NUM(Int32 i)
    {
        return rb_int2inum(i);
    }

    // 略
}</code></pre></figure>

<h3 id="文字列変換">文字列変換</h3>

<h4 id="ruby-文字列--c-文字列-1">Ruby 文字列 → C# 文字列</h4>

<p>前述の通り、 StringValuePtr を使います。</p>

<h4 id="c-文字列--ruby-文字列">C# 文字列 → Ruby 文字列</h4>

<p>rb_str_new2 関数をポーティングします。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    [DllImport(RubyDll)]
    public static extern VALUE rb_str_new2(byte[] ptr);

    public static VALUE rb_str_new2(string ptr)
    {
        return rb_str_new2(Encoding.UTF8.GetBytes(ptr + '\0'));
    }

    // 略
}</code></pre></figure>

<p>本来 C では</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">VALUE rb_str_new2(char *ptr);</code></pre></figure>

<p>と定義されており、 C の char * 型を C# byte[] 型としました。この関数のほかに、 string を引数にとるメソッドを別途作りました。最初の rb_eval_string_protect と同じ要領です。</p>

<h3 id="c-から-ruby-のメソッド呼び出し">C# から Ruby のメソッド呼び出し</h3>

<p>Ruby のオブジェクトのメソッドを呼び出すためには、 rb_funcall 関数を使います。 rb_funcall 関数の定義は以下の通り。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">VALUE rb_funcall(VALUE recv, ID mid, int argc);</code></pre></figure>

<p>ID は変数名やメソッド名を一意に定める値で、 Symbol のことです。文字列から Symbol を取得するには、 rb_intern 関数を使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">ID rb_intern(const cahr *name);</code></pre></figure>

<p>ID は単なる整数値なので、 C# では int として扱えます。</p>

<p>両方を C# で定義してやると、以下のようになります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">using ID = System.Int32;

// 略

static class Ruby
{
    // 略

    [DllImport(RubyDll, EntryPoint = "rb_funcall")]
    private static extern VALUE rb_funcall_(VALUE recv, ID mid, int argc);
    public static VALUE rb_funcall(VALUE recv, ID mid)
    {
        return rb_funcall_(recv, mid, 0);
    }
    [DllImport(RubyDll, EntryPoint="rb_funcall")]
    private static extern VALUE rb_funcall_(VALUE recv, ID mid, int argc, VALUE arg1);
    public static VALUE rb_funcall(VALUE recv, ID mid, VALUE arg1)
    {
        return rb_funcall_(recv, mid, 1, arg1);
    }
    [DllImport(RubyDll, EntryPoint = "rb_funcall")]
    private static extern VALUE rb_funcall_(VALUE recv, ID mid, int argc, VALUE arg1, VALUE arg2);
    public static VALUE rb_funcall(VALUE recv, ID mid, VALUE arg1, VALUE arg2)
    {
        return rb_funcall_(recv, mid, 2, arg1, arg2);
    }

    [DllImport(RubyDll)]
    public static extern ID rb_intern(byte[] name);
    public static ID rb_intern(string name)
    {
        return rb_intern(Encoding.UTF8.GetBytes(name + '\0'));
    }

    // 略
}</code></pre></figure>

<h3 id="c-による-ruby-のクラス定義">C# による Ruby のクラス定義</h3>

<p>rb_define_class 関数を使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">static class Ruby
{
    // 略

    [DllImport(RubyDll)]
    public static extern VALUE rb_define_class(string name, VALUE super);

    // 略
}</code></pre></figure>

<p>rb_define_class 関数は親クラスの指定が必須ですが、 rb_cObject (Object クラスを表す VALUE) が無くて困ることになります。 rb_cObject はグローバル変数ですが、 C/C# のデータ変換ができないのです。 rb_eval_string_protect を使って強引に切り抜けましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">VALUE rb_cObject = Ruby.rb_eval_string_protect("Object", ref state);</code></pre></figure>

<h2 id="問題点">問題点</h2>

<h3 id="実行環境が限定される">実行環境が限定される</h3>

<p>実行環境はそのアプリケーション内でのみ限定されます。拡張ライブラリのような使い方はできません。</p>

<p><a href="http://www.enterbrain.co.jp/digifami/products/rpgxp/">RPG ツクール XP</a>のように完全に閉じた世界の Ruby のような、特殊な用途ならば大丈夫でしょう。</p>

<h3 id="cc-のデータ変換はコストがかかる">C/C# のデータ変換はコストがかかる</h3>

<p>C/C# のデータ変換は、通常の関数呼び出しに比べて大きなコストがかかります。高速化のためには、以下の工夫が必要でしょう。</p>

<ul>
  <li>呼び出し回数を減らす</li>
  <li>シンボルをキャッシュする (同じ文字列に対する ID 値は不変なため)</li>
  <li>Fixnum の計算をシフト演算で何とかする</li>
</ul>

<h3 id="gc-が独立して動いてしまう">GC が独立して動いてしまう</h3>

<p>Ruby の GC と C# の GC は独立して動きます。 Ruby のオブジェクトと C# のオブジェクトとを関連付ける場合、片方が GC で回収されてしまうなどの不整合を起こさないようにしましょう。</p>

<p>C# 側では連想配列などを使って常に参照を保持するようにし、 Ruby のオブジェクトを回収のタイミングをフックして、 C# のオブジェクトを回収させるようにすればよいでしょう。 ObjectSpace モジュールの define_finalizer メソッドを使いましょう。</p>

<h2 id="おわりに">おわりに</h2>

<p>本稿では、 C# と Ruby を連携させる方法について述べました。本稿で紹介する方法を使うことによって、 C# における .NET ライブラリの豊富さと、 Ruby のスクリプトの書きやすさの両方のメリットを受けることができます。また、ポーティング作業を通じて、 Ruby の C API やマーシャリング (C/C# データ変換) を学ぶことができます。</p>

<p>しかしながら、 Ruby で .NET のライブラリを使いたいという目的ならば、今後は IronRuby を使ったほうがよいでしょう。</p>

<h2 id="宣伝">宣伝</h2>

<p><a href="http://star-engine.sourceforge.jp/">Star Engine</a> というゲームライブラリを開発しております。スーパーファミコン風なノスタルジックなゲームを簡単に作るためのライブラリです。 C# と Ruby の組合せを使っています。</p>

<p>画像操作などの速度が要求される部分は C# で書かれており、ゲームを作る「楽しい」部分は Ruby で書けるようになっています。</p>

<p>C# で書くことによって、 .NET の恩恵をそのまま受けることが出来ました。特に画像処理やフォント周りとかが楽チンでした<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>。</p>

<h2 id="謝辞">謝辞</h2>

<p>本稿を書くにあたって、 NyaRuRu さん、 arton さん、ささださん (順不同) にアドバイスをいただきました。この場を借りて厚く御礼申し上げます。</p>

<h2 id="書いた人">書いた人</h2>

<p>星一。大学院生。色々と面倒くさがり屋。好きなアーティストは Michael Jackson です。</p>

<ul>
  <li><a href="http://d.hatena.ne.jp/hajimehoshi/">http://d.hatena.ne.jp/hajimehoshi/</a></li>
  <li><a href="http://twitter.com/hajimehoshi">http://twitter.com/hajimehoshi</a></li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>差異は、http://www.garbagecollect.jp/ruby/mswin32/ja/documents/mswin32.htmlを参照。&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>ライセンスが GPL ですので、公開する際は注意してください。&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>参考: http://msdn2.microsoft.com/ja-jp/library/04fy9ya1(VS.80).aspx&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>README.EXT.ja によると、 16 個が限界らしい。&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>厳密には、 C# のデリゲートと C の関数ポインタを仲介する Reverse P/Invoke thunk というサンクというものが存在し、デリゲートインスタンスごとに実行時生成されます。 C から関数ポインタをコールするとき、実際にはこのサンクが呼ばれます。サンクはデリゲートインスタンスと一対一に対応し、デリゲートインスタンスが回収されたときにサンクも破棄されることになっています。&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>組み込み変数: http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%CA%D1%BF%F4&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>SDL を使っていますが、 SDL_ttf などはあまり使いたくなかったんです。&nbsp;<a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
