<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ruby 1.9 で Web アプリを想定したベンチマークをとってみた</title>
  <meta name="description" content="著者: 桑田 誠">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/css/theme.css" rel="stylesheet" type="text/css">
  <link href="/css/syntax.css" rel="stylesheet" type="text/css">

  <link rel="canonical" href="http://magazine.rubyist.net/articles/0025/0025-Ruby19_Performance.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="http://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="/images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-1 hidden-xs sidebar">
                <img src="../images/rubima_logo_left_top.png" alt="Rubima Logo" class="img-responsive">

<h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="/articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="/articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="/articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="/articles/pretokyorubykaigi11/preTokyoRubyKaigi11.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="/articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="/articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="/articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="/articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="/articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="/articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="/articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="/articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="/articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="/articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="/articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="/articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="/articles/ruby200specialen/Ruby200SpecialEn.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="/articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="/articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="/articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="/articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="/articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="/articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="/articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="/articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="/articles/prerubykaigi2011/preRubyKaigi2011.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="/articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="/articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="/articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="/articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="/articles/prerubykaigi2010/preRubyKaigi2010.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="/articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="/articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="/articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="/articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="/articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="/articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="/articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="/articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="/articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="/articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="/articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="/articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="/articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="/articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="/articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="/articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="/articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="/articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="/articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="/articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="/articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="/articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="/articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="/articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="/articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="/articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="/articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="/articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="/articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="/articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="/articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-11 main">
                <img src="/images/rubima_logo_l.png">
                <h1>Ruby 1.9 で Web アプリを想定したベンチマークをとってみた</h1>
                <div class="social-buttons">
                    <a href="http://b.hatena.ne.jp/entry//articles/0025/0025-Ruby19_Performance.html" class="hatena-bookmark-button" data-hatena-bookmark-title="Ruby 1.9 で Web アプリを想定したベンチマークをとってみた" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<span id="fb-root"></span>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.5";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<span class="fb-like" data-href="/articles/0025/0025-Ruby19_Performance.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></span>
<a href="https://twitter.com/share" class="twitter-share-button" data-url="/articles/0025/0025-Ruby19_Performance.html" data-text="Ruby 1.9 で Web アプリを想定したベンチマークをとってみた">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                </div>
                <p>著者: 桑田 誠</p>

<ul id="markdown-toc">
  <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a>    <ul>
      <li><a href="#ベンチマーク環境" id="markdown-toc-ベンチマーク環境">ベンチマーク環境</a></li>
      <li><a href="#ベンチマークスクリプト" id="markdown-toc-ベンチマークスクリプト">ベンチマークスクリプト</a></li>
    </ul>
  </li>
  <li><a href="#フィボナッチ数列のベンチマーク" id="markdown-toc-フィボナッチ数列のベンチマーク">フィボナッチ数列のベンチマーク</a></li>
  <li><a href="#eruby-によるベンチマーク" id="markdown-toc-eruby-によるベンチマーク">eRuby によるベンチマーク</a></li>
  <li><a href="#html-エスケープに関するベンチマーク" id="markdown-toc-html-エスケープに関するベンチマーク">HTML エスケープに関するベンチマーク</a></li>
  <li><a href="#データベースを使ったベンチマーク" id="markdown-toc-データベースを使ったベンチマーク">データベースを使ったベンチマーク</a></li>
  <li><a href="#考察" id="markdown-toc-考察">考察</a>    <ul>
      <li><a href="#言語の速度は手段でしかない" id="markdown-toc-言語の速度は手段でしかない">言語の速度は手段でしかない</a></li>
      <li><a href="#個人的に-ruby-19-に期待すること" id="markdown-toc-個人的に-ruby-19-に期待すること">個人的に Ruby 1.9 に期待すること</a></li>
    </ul>
  </li>
  <li><a href="#おわりに" id="markdown-toc-おわりに">おわりに</a></li>
</ul>

<h2 id="はじめに">はじめに</h2>

<p>以前から Ruby の動作速度は遅いといわれていました。
しかし、アプリケーションの動作速度にはデータベースやライブラリやアルゴリズムなどが大きく影響するため、言語の速度がアプリケーションの速度を決定するわけではありません。</p>

<p>本稿では以下のような複数の Ruby 実装でベンチマークをとることで、__言語の速度がそのままアプリケーションの速度になるわけではない__ことを具体的に説明します。</p>

<ul>
  <li>Ruby 1.8.7</li>
  <li>Ruby 1.9.1</li>
  <li>Rubinius (2009-01-18 版)</li>
</ul>

<p>なお本稿で想定するアプリケーションは、一般的な Web アプリケーションです。
これは、現在 Ruby がいちばんよく使われている分野が Web アプリケーションであることが理由です。</p>

<h3 id="ベンチマーク環境">ベンチマーク環境</h3>

<p>今回は、Mac OS X 環境と Linux 環境とでベンチマークを行ないました。
各環境のマシンは次の通りです。</p>

<ul>
  <li>Mac OS X
    <ul>
      <li>Version: 10.5.6 (Darwin 9.6.0)</li>
      <li>CPU: Intel Core 2 Duo 2.8 GHz</li>
      <li>Memory: 2 GB 800 MHz DDR2 SDRAM</li>
    </ul>
  </li>
  <li>Linux
    <ul>
      <li>Version: Redhat 5.2 (2.6.18-53.1.14.el5 SMP i386 GNU/Linux)</li>
      <li>CPU: Intel Xeon 3065 2.33GHz (stepping 11)</li>
      <li>Memory: 1 GB</li>
    </ul>
  </li>
</ul>

<p>また各 Ruby 実装のバージョンは以下の通りです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">### Mac OS X
$ ruby187 -v
ruby 1.8.7 (2008-08-11 patchlevel 72) [i686-darwin9.6.0]
$ ruby191 -v
ruby 1.9.1 (2008-12-30 patchlevel-0 revision 21203) [i386-darwin9.6.0]
$ rbx -v
rubinius 0.10.0 (ruby 1.8.6) (6de41e35a 12/31/2009) [i686-apple-darwin9.6.0]</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">### Linux
$ ruby187 -v
ruby 1.8.7 (2008-08-11 patchlevel 72) [i686-linux]
$ ruby191 -v
ruby 1.9.1 (2008-12-30 patchlevel-0 revision 21203) [i686-linux]
$ rbx -v
rubinius 0.10.0 (ruby 1.8.6) (6de41e35a 12/31/2009) [i686-pc-linux-gnu]</code></pre></figure>

<h3 id="ベンチマークスクリプト">ベンチマークスクリプト</h3>

<p>ベンチマークスクリプトはすべて<a href="http://github.com/kwatch/shelves/tree/HEAD/rubyist-magazine/0025-appbench">githubから入手できます</a>。</p>

<h2 id="フィボナッチ数列のベンチマーク">フィボナッチ数列のベンチマーク</h2>

<p>まず、ベンチマークとしてはポピュラーなフィボナッチ数列を試してみましょう。</p>

<p>fib-bench.rb:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">def fib(n)
  n &lt;= 1 ? 1 : fib(n-1) + fib(n-2)
end

n = (ENV['N'] || $N || 35).to_i
p fib(n)</code></pre></figure>

<p>実行結果 (Mac OS X):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ /usr/bin/time ruby187 -s fib-bench.rb -N=35
14930352
       11.78 real        11.72 user         0.01 sys

[macosx]$ /usr/bin/time ruby191 -s fib-bench.rb -N=35
14930352
        3.05 real         3.03 user         0.01 sys

[macosx]$ N=35 /usr/bin/time rbx fib-bench.rb
14930352
        5.85 real         5.78 user         0.03 sys</code></pre></figure>

<p>実行結果 (Linux):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[linux]$ /usr/bin/time ruby187 -s fib-bench.rb -N=35
14930352
13.54user 0.00system 0:13.55elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+433minor)pagefaults 0swaps

[linux]$ /usr/bin/time ruby191 -s fib-bench.rb -N=35
14930352
2.78user 0.00system 0:02.78elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+690minor)pagefaults 0swaps

[linux]$ N=35 /usr/bin/time rbx  fib-bench.rb 
14930352
6.22user 0.01system 0:06.24elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+4995minor)pagefaults 0swaps</code></pre></figure>

<p>実行結果をみると、</p>

<ul>
  <li>Ruby 1.9.1 は Ruby 1.8.7 の約 4 倍から 5 倍高速</li>
  <li>Rubinius は Ruby 1.8.7 の約 2 倍高速</li>
</ul>

<p>という結果になりました。
特に Ruby 1.9.1 は、(いい意味で) とても同じ Ruby とは思えないぐらいの実行結果を叩きだしています。</p>

<p>ただ Web アプリケーションでフィボナッチ数列が必要となることはまずありません。
そこで今度は、より Web アプリケーションよりのベンチマークをとってみることにします。</p>

<h2 id="eruby-によるベンチマーク">eRuby によるベンチマーク</h2>

<p>Web アプリケーション寄りのベンチマークで、かつ手軽に試せるものとして、eRuby を使ったベンチマークを用意しました (<a href="http://github.com/kwatch/shelves/tree/HEAD/rubyist-magazine/0025-appbench">こちら</a>に置いてあります)。
このベンチマークは、eRuby を使って約 330 行の HTML ページを生成するベンチマークです。</p>

<p>なお eRuby 処理系としては <a href="http://www.kuwata-lab.com/erubis/">Erubis</a> を使用しています。
これは、ERB だと Ruby のバージョンによって大きく速度が異なるため、今回のベンチマークにはふさわしくないと判断したためです。</p>

<p>eruby-bench.rb:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## オプションの解析 
$N = ENV['N'] unless defined?($N)       # 繰り返し回数
$e = ENV['E'] unless defined?($e)       # HTML エスケープする/しない
$cgiext = nil unless defined?($cgiext)  # require 'cgiext' する/しない

## eRuby ファイルをコンパイルしてメソッドに変換
require 'rubygems'
require 'erubis'
filename = "view.rhtml"
str = File.read(filename)
escape = $e ? true : false
eruby = Erubis::FastEruby.new(str, :escape=&gt;escape)
src = eruby.src
eval "def render(list); #{src}; end", binding(), filename

## テストデータの読み込み
class StockInfo
  attr_accessor :name, :url, :symbol      # string
  attr_accessor :price, :change, :ratio   # float
end
require "yaml"
data = YAML.load_file("data.yaml")
list = []
data["list"].each do |hash|
  item = StockInfo.new
  item.name   = hash['name']
  item.url    = hash['url']
  item.symbol = hash['symbol']
  item.price  = hash['price']
  item.change = hash['change']
  item.ratio  = hash['ratio']
  list &lt;&lt; item
end

## その他の処理
require "cgiext" if $cgiext
$N = ($N || 100000).to_i
if $N == 1
  print render(list)
  exit
end

## ベンチマークを実行
require "benchmark"
Benchmark.bm do |r|
  r.report do
    $N.times { render(list) }
  end
end</code></pre></figure>

<p>実行結果 (Mac OS X):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ ruby187 -s eruby-bench.rb -N=100000
      user     system      total        real
 23.250000   0.060000  23.310000 ( 23.798767)

[macosx]$ ruby191 -s eruby-bench.rb -N=100000
      user     system      total        real
 26.040000   0.090000  26.130000 ( 26.243537)

[macosx]$ N=100000 rbx bench2.rb
      user     system      total        real
442.980005   0.000000 442.980005 (442.980004)</code></pre></figure>

<p>実行結果 (Linux):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[linux]$ ruby187 -s eruby-bench.rb -N=100000
      user     system      total        real
 22.520000   0.000000  22.520000 ( 22.520964)

[linux]$ ruby191 -s eruby-bench.rb -N=100000
      user     system      total        real
 23.460000   0.090000  23.550000 ( 23.558899)

[linux]$ N=100000 /usr/bin/time rbx eruby-bench.rb 
      user     system      total        real
475.965906   0.000000 475.965906 (475.965864)</code></pre></figure>

<p>この結果を見ると、</p>

<ul>
  <li>Ruby 1.9.1 は Ruby 1.8.7 より約 5 % から 10 % 遅い</li>
  <li>Rubinius は Ruby 1.8.7 より約 20 倍遅い</li>
</ul>

<p>という結果になりました。
フィボナッチ数列のベンチマークとはまるで違います。
特に Rubinius は、(悪い意味で) とても同じ Ruby とは思えないほどの結果となってしまいました。</p>

<p>Ruby 1.9.1 が 1.8.7 より遅いのはおそらく、文字列の多言語化 (M18N) によって文字列処理のコストが増大したせいだと思われます。
また Rubinius が極端に遅いのは、Rubinius の String クラスが C ではなく Ruby で実装されていることが原因でしょう。
つまり、文字列処理に関しては Ruby 1.8.7 がいちばん高速であり、それが eRuby のベンチマーク結果に反映されたということです。</p>

<p>Web アプリケーションでは、数値計算よりも文字列処理のほうがずっと多いです。
そのため、フィボナッチ数列のようなベンチマークをとったところで Web アプリケーションの速度は分かりません。
特に今回のようなベンチマークでは、処理系エンジンの性能よりも、組み込み関数やメソッドの実行速度のほうが重要になります。
Ruby 1.8.7 では文字列に関する組み込みメソッドが C 言語で実装されているため十分高速であり、Rubinius のように C で実装されていない場合は極端に遅くなることがあるわけです。</p>

<p>今回のベンチマーク結果を見ると、__アプリケーションの速度には処理系の速度よりも組み込み関数やメソッドの性能のほうが重要__であることがわかります。</p>

<h2 id="html-エスケープに関するベンチマーク">HTML エスケープに関するベンチマーク</h2>

<p>先ほどの eRuby ベンチマークでは、HTML エスケープ処理をしていませんでした。
実は HTML エスケープ処理も含めてベンチマークをとると、興味深い結果が得られます。
ここではそれを紹介してみます。</p>

<p>HTML エスケープ処理を含めてベンチマークをするには、先ほどのベンチマークスクリプトに「-e」オプションをつけるか、環境変数「$E」を設定します。</p>

<p>実行結果 (Mac OS X):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ ruby187 -s eruby-bench.rb -N=100000 -e
      user     system      total        real
 49.010000   0.180000  49.190000 ( 49.313947)

[macosx]$ ruby191 -s eruby-bench.rb -N=100000 -e
      user     system      total        real
 65.310000   0.170000  65.480000 ( 65.673570)

[macosx]$ N=100000 E=true rbx eruby-bench.rb
      user     system      total        real
672.767837   0.000000 672.767837 (672.767842)</code></pre></figure>

<p>実行結果 (Linux):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[linux]$ ruby187 -s eruby-bench.rb -N=100000 -e
      user     system      total        real
 47.410000   0.050000  47.460000 ( 47.468278)

[linux]$ ruby191 -s eruby-bench.rb -N=100000 -e
      user     system      total        real
 58.130000   0.010000  58.140000 ( 58.146540)

[linux]$ N=100000 E=true rbx eruby-bench.rb
      user     system      total        real
709.440972   0.000000 709.440972 (709.440978)</code></pre></figure>

<p>この結果を見ると、次のことがわかります。</p>

<ul>
  <li>Ruby 1.8.7 では、HTML エスケープ “あり” は “なし” より 2 倍以上遅い</li>
  <li>Ruby 1.9.1 では、HTML エスケープ “あり” は “なし” より約 2.5 倍遅い</li>
  <li>Rubinius では、HTML エスケープ “あり” は “なし” より約 1.5 倍遅い</li>
</ul>

<p>つまり、__eRuby による HTML 生成コストより HTML エスケープ処理のコストのほうが大きい__というわけです。</p>

<p>今回のベンチマークで使ったデータには、HTML エスケープが必要な文字 (「&amp;&lt;&gt;“」) は一切含まれていません。
にも関わらず、たかが HTML エスケープ処理の動作コストが eRuby のコストより大きいという事実には驚かされます。</p>

<p>この理由ですが、まず Erubis では正規表現を使って HTML エスケープ処理を行なっています。
そのため、正規表現の動作コストが文字列処理のコストよりずっと大きいということが言えると思います。
また Ruby 1.8.7 より Ruby 1.9.1 のほうが速度低下の割合が遅くなっているのは、Ruby 1.9.1 では正規表現ライブラリを高機能なものに変更したことが原因と思われます。</p>

<p>それでは、もし HTML エスケープ処理を C 言語で実装したらどのくらい速度が向上するでしょうか。</p>

<p>それを確かめるために、CGIExt を使ってみましょう。
<a href="http://cgialt.rubyforge.org/">CGIExt</a> は cgi.rb での関数の一部を C 言語による拡張モジュールとして実装したライブラリであり、require するだけで HTML エスケープ用関数 (CGI.escapeHTML() や ERB::Util#h() や Erubis::XmlHelper.escape_xml()) を C 実装に置き換えます。
今のところ Ruby 1.8.x にしか対応してないので、Ruby 1.9.1 や Rubinius では使えないことに注意してください。</p>

<p>なお先ほどのベンチマークスクリプトに「-cgialt」オプションをつけると、CGIAlt を使ったベンチマークができます。</p>

<p>実行結果 (Mac OS X):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ ruby187 -s eruby-bench.rb -N=100000 -e -cgialt
      user     system      total        real
 26.750000   0.030000  26.780000 ( 26.852012)</code></pre></figure>

<p>実行結果 (Linux):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[linux]$ ruby187 -s eruby-bench.rb -N=100000 -e -cgialt
      user     system      total        real
 27.080000   0.000000  27.080000 ( 27.096098)</code></pre></figure>

<p>この結果を見ると、次のことがわかります。</p>

<ul>
  <li>CGIExt を使えば、HTML エスケープ処理があった場合でもない場合と比べて約 15 % から 20 % の速度低下で済む。</li>
</ul>

<p>先ほど、「アプリケーションの速度には処理系の速度より組み込みの関数やメソッドの速度のほうが重要」と書きました。
今回の結果はこの主張を裏付けるものになっています。
つまり、自分のアプリケーションで必要とする機能が組み込みや拡張モジュールとして提供されていれば、たとえ処理系の速度が遅くても、最終的なアプリケーション速度は速くなるわけです。</p>

<p>これは Java など静的な言語だけをやっていた人が勘違いしやすい点なので注意してください:
Ruby などスクリプト言語の処理系では、組み込み関数やメソッドは大抵 C/C++ 言語で実装されているため、それらを呼び出すだけならスクリプト言語でも十分高速です。
また必要なライブラリが C 言語による拡張モジュールで提供されている場合も同様に高速です。
そして、それらがどれだけ用意されているかでアプリケーションの速度は大きく変わります。
言葉を変えていえば、スクリプト言語では__組み込み関数やライブラリの品揃えでアプリケーション速度は大きく変わる__といえます。</p>

<p>余談になりますが、これは Web アプリケーションの分野において PHP が高速である理由のひとつでもあります。
各種言語でベンチマークをとると、PHP は Perl や Ruby より遅いです。
しかし実際に Web アプリケーションを使ってみると、PHP は他の言語より軽快に動作しているように感じます。
これは、HTML エスケープやリクエストパラメータ解析のような Web アプリケーションでよく使われる処理を、PHP では C 言語による組み込みの関数として提供していることが理由のひとつであると思われます。</p>

<h2 id="データベースを使ったベンチマーク">データベースを使ったベンチマーク</h2>

<p>ベンチマークの最後として、データベース処理を含めたベンチマークを実行してみます。
内容はコメントつきの Blog アプリケーションであり、使用したデータベースとデータ件数は以下の通りです。</p>

<ul>
  <li>MySQL バージョン: 5.0.67</li>
  <li>データ件数: ユーザ 10 人 + ブログエントリ 5000 件 + コメント 10000 件</li>
</ul>

<p>ベンチマークスクリプトの詳細は<a href="http://github.com/kwatch/shelves/tree/HEAD/rubyist-magazine/0025-appbench">こちら</a>にある blog-bench.* を参照してください。
今回は環境の都合により、Mac OS X 上で Ruby 1.8.7 と 1.9.1 を使ったときの結果のみ紹介します。</p>

<p>実行結果 (Mac OS X):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ ruby187 -s blog-bench.rb -N=500
      user     system      total        real
  3.440000   0.580000   4.020000 ( 31.501939)
[macosx]$ ruby191 -s blog-bench.rb -N=500
      user     system      total        real
  3.380000   0.580000   3.960000 ( 31.460440)</code></pre></figure>

<p>この結果から、次のようなことがわかります。</p>

<ul>
  <li>Ruby による消費時間を比べると、Ruby 1.8.7 より 1.9.1 のほうが約 1 % ほど速い。</li>
  <li>全体の実行時間のうち、Ruby による消費時間はわずか数パーセントにすぎない。</li>
</ul>

<p>このベンチマークでは、Ruby 1.8.7 より 1.9.1 のほうが若干ではありますが高速でした。
先の eRuby ベンチマークでは 1.8.7 のほうが高速だったことを考えると、これはモデル操作の部分で Ruby 1.9.1 が逆転したと考えてよいでしょう。
つまり、MVC モデルにおける V は 1.8.7 のほうが速いが M は 1.9.1 のほうが速い、あるいは、__モデル操作が多い複雑なアプリケーションほど Ruby 1.9.1 のほうが速い__と言えます。</p>

<p>ただし、全体の時間が約 31.5 秒もかかっているのに、そのうち Ruby によって消費された時間はわずか 3.5 秒程度です。
このことから、全体の実行時間のうちほとんどはデータベースによって消費されていることがわかります<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>この結果を見ると、言語の速度を競うのがいかにばからしいことかと思い知らされます。
もちろん言語の速度が必要なアプリケーションも数多くあるでしょう。
しかしデータベースを扱うようなアプリケーションであれば、いちばんのボトルネックはデータベース周りであり、そこを改善せずに言語まわりを改善したところで大して効果はありません。</p>

<p>そして、この傾向は__大規模システムであればあるほど顕著になる__ことに注意してください。
今回のベンチマークでは__わずか__ 1.5 万件程度のデータしか扱っていませんが、実際の大規模システムではこの 100 倍や 1000 倍あるのは珍しくありません。
そして、そのようにデータ量が大量になればなるほどボトルネックになるのはデータベースであり<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>、言語処理系の速度はあまり問題にならなくなります<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>。</p>

<p>ちなみに、このベンチマークで使ったテーブルと SQL にはボトルネックがあります。
該当箇所の create table 文と select 文は以下の通りですが、これらのうちどの部分がボトルネックになっているか、みなさんお分かりになるでしょうか。</p>

<p>create table 文:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">create table blog_entries(
  id          integer         primary key auto_increment,
  user_id     integer         not null references blog_users(id),
  title       varchar(200)    not null,
  body        text(4000)      not null,
  updated_at  timestamp       not null,
  created_at  timestamp       not null,
  deleted_at  timestamp       null default null,
  index blog_entries_user_id(user_id)
);</code></pre></figure>

<p>select 文:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">ENTRIES_SQL = &lt;&lt;END
select blog_entries.* from blog_entries, blog_users
where blog_entries.user_id = blog_users.id
  and blog_users.name = ?
order by blog_entries.id desc
limit 0, 20
END</code></pre></figure>

<p>さて、どこがボトルネックでしょうか。
みなさん考えてみてください。</p>

<p>答えは 30 秒後、CM のあとで!</p>

<p>　</p>

<p>　</p>

<hr />

<p>◇◆◇ CM中 ◇◆◇</p>

<p><img class="" src="https://images-fe.ssl-images-amazon.com/images/I/41CGDEMgyoL._SL160_.jpg" />
<strong>『プログラミング言語 Ruby』</strong></p>

<p>David Flanagan, まつもと ゆきひろによる Ruby の解説書が出版されました。
Ruby の父が 10 年ぶりに書いた待望の書籍、絶賛発売中！</p>

<ul>
  <li>David Flanagan, まつもと ゆきひろ 著、卜部 昌平 監訳、長尾 高弘 訳</li>
  <li>2009 年 01 月 24 日 発売</li>
  <li>472 ページ</li>
  <li>定価 3,990 円</li>
  <li>ISBN: 978-4-87311-394-4</li>
  <li>原書: The Ruby Programming Language</li>
</ul>

<hr />

<p>　</p>

<p>　</p>

<p>みなさん、わかりましたでしょうか。
筆者はデータベースが得意ではないのですが、調べた限りでは blog_entries テーブルにつけたインデックス (blog_entries_user_id) が原因でした。
このインデックスがついていると、select 文の結果をソートする際に PRIMARY インデックスが使われないため、遅くなるようです<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>。
この問題の対策としては、次の 2 つがあります。</p>

<ol>
  <li>インデックスを削除する (alter table blog_entries drop index blog_entries_user_id)</li>
  <li>PRIMARY インデックスを使うことを明示的する (select * from blog_entries use index (PRIMARY), …)</li>
</ol>

<p>今回は後者を試してみましょう。
ベンチマークスクリプトに -useindex オプションをつけると、「from blog_entries」を「from blog_entries use index (PRIMARY)」に変更してくれます。
筆者の環境で試してみると、31.5 秒かかっていたのが 12 秒にまで縮まりました。
ActiveRecord などの O/R マッパーでは use index のような構文をサポートしてないことを考えると、データベースに詳しい人ほど O/R マッパーを嫌がるのもわかります。</p>

<p>実行結果 (Mac OS X, -useindex オプションつき):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[macosx]$ ruby187 -s blog-bench.rb -N=500 -useindex
      user     system      total        real
  3.180000   0.420000   3.600000 ( 12.085999)
[macosx]$ ruby191 -s blog-bench.rb -N=500 -useindex
      user     system      total        real
  3.120000   0.410000   3.530000 ( 11.948881)</code></pre></figure>

<p>ただ、それでもまだデータベースがボトルネックになっていることにかわりはありません。
今回の場合ですと、Ruby の部分をチューニングしても最大で 3 秒程度しか縮まりませんが、SQL をチューニングすると簡単に約 20 秒も縮まり、またあと 12 秒ほどチューニングの余地があります。
つまり、Ruby をより速い言語に変えて 3 秒を縮めるよりも、テーブルを分割したり SQL の実行結果をキャッシュすることで 12 秒を縮めることを考えるべきだということがわかります。</p>

<p>今回の SQL はごく簡単だったので解決方法もわかりやすかったですが、実際のアプリケーションで使われる SQL はもっと複雑になるため、何がボトルネックでどう解決すればいいのかはそう簡単には分かりません。
ここでも、「大規模で複雑なシステムほど SQL のチューニングがより重要になるため、相対的に言語の速さは重要でなくなる」ことがわかります。</p>

<p>このように、データベースを使うアプリケーションではデータベース周りこそがボトルネックです。
そしてこの傾向は、大規模システムになるほど顕著になります。
Ruby が遅いと文句をいう前に、Ruby による部分が本当にボトルネックになっているかを確認してから、速い言語を求めましょう。
少なくとも、前述の SQL におけるボトルネックが分からなかったプログラマーや、MySQL を使っていながら use index を知らないようなプログラマーに、言語の速さがどうのこうのという資格はないでしょう<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> 。</p>

<h2 id="考察">考察</h2>

<p>ここまでお読みになっていただき、ありがとうございます。
せっかくの機会ですので、筆者の戯れ言にもうしばらくお付き合い下さい。</p>

<h3 id="言語の速度は手段でしかない">言語の速度は手段でしかない</h3>

<p>冒頭部分の繰り返しになりますが、本稿での主張は「言語の速度がそのままアプリケーションの速度になるわけではない」あるいは「言語の速度とアプリケーションの速度は別モノ」ということです。</p>

<p>この主張には、ある重大な前提が隠されています。
それは、我々が最終的に必要としているのは「アプリケーションの速さ」であって「言語の速さ」ではないということです。
我々にとっては__「アプリケーションの速さ」こそが目的であり、「言語の速さ」はそのための手段でしかありません__<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>。</p>

<p>勘違いしないでいただきたいのですが、言語処理系の性能に無頓着でいいと主張しているわけではありません。
言語の性能は大事です。ただ、同じくらい大事な (あるいはそれより大事な) 要因が他にも多くあるという、ごくごく当たり前のことを言っているまでです。</p>

<p>アプリケーションの速度には実にさまざまな要因が絡んできます。
それはデータベースだったり、アーキテクチャだったり、フレームワークやライブラリだったり、ネットワークや I/O の性能だったり、アルゴリズムやデータ構造だったり、プログラム上のアイデアだったりします。
そして言語処理系の速度というのは、いくつもある要因のうちの 1 つにすぎません。
「速い言語 + 遅いライブラリ」よりも「遅い言語 + 速いライブラリ」のほうが最終的なアプリケーションの動作は速い、なんてことはよくあることです。
しかしそのことに気づかず、言語処理系の速度ばかりが偏重される傾向にあるのは残念なことです。</p>

<p>筆者は、「1.9 になればアプリケーションが 3 倍速くなる!」とか、「1.8 とは違うのだよ、1.8 とは!」のように、Ruby 1.9 に対して過剰で能天気な期待をしている人の存在に危惧しています。
過剰な期待は過剰な失望を生み出しかねません。
Ruby 1.9 の高速化が世間で適切に評価されるためには、過剰な期待はマイナスにしかならないでしょう。
それよりも、Ruby が高速化された今こそ、言語の速度とアプリケーションの速度は別モノであると世の中に知らしめる好機ではないでしょうか。</p>

<h3 id="個人的に-ruby-19-に期待すること">個人的に Ruby 1.9 に期待すること</h3>

<p>現在、Ruby がいちばんよく使われているのは Web アプリケーション関連ですが、それらは Ruby 1.9 にしたところで大して速くはならないと筆者は考えています。
また今回のベンチマーク結果はそれを裏付けています。</p>

<p>それでは Ruby 1.9 は要らない子なのでしょうか?</p>

<p>そんなことはありません。
筆者は、Ruby 1.9 は既存の Web アプリケーションを高速化するものではなく、Web アプリケーション以外での Ruby の利用を促してくれるもの、いわば __Ruby の可能性を広げるもの__だと考えています。</p>

<p>Ruby が Web アプリケーション分野でよく使われているということは、裏返していうと、今までの Ruby が遅かったせいで Web アプリケーション以外の分野ではあまり使われていなかった、と捉えることもできます。
文字列処理の多い Web アプリケーションでは Ruby でも問題ないでしょうが、そうではない分野では Ruby の遅さがネックになっていることもあるでしょう。
Ruby が高速化されたおかげで、そういった分野にも Ruby が進出できるようになります。</p>

<p>たとえば、現在の Web アプリケーションではデータエントリ (データの入力と出力) が中心ですが、今後 Ruby が本気でエンタープライズ分野に進出するのであれば、統計処理やビジネスインテリジェンスといった、データの集計を行なうアプリケーションも視野にいれるべきでしょう。
そして、こういったアプリケーションでは文字列処理よりも数値計算やループの性能が重要になるため、Ruby 1.8 ではつらかったとしても 1.9 なら適用できる可能性があります。</p>

<p>また Ruby 1.9 では <a href="http://doc.loveruby.net/refm/api/view/class/Fiber">Fiber</a> が利用可能となっています。
これは Ruby で利用可能なアーキテクチャを大きく拡張するものであり、個人的に大変期待しています。
特に Fiber を使った非同期 I/O はデータベースまわりのボトルネックを大幅に解消できる可能性があり、実際に <a href="http://www.espace.com.eg/neverblock">NeverBlock</a> というライブラリでは MySQL へのクエリーを非同期化することで<a href="http://www.espace.com.eg/neverblock/benchmarks">性能を大幅に高めている</a>そうです。
聞いたところによると、ささだ先生としては Fiber をまだ積極的には使ってほしくないそうですが、データベース周りが高速化できると聞かされれば期待するなというほうが無理でしょう。
少なくとも今の筆者は過剰なくらい期待しています :)</p>

<h2 id="おわりに">おわりに</h2>

<p>本稿では Web アプリケーションを想定したベンチマークをとることで、「言語の速度がそのままアプリケーションの速度になるわけではない」あるいは「言語の速さとアプリケーションの速さは別モノである」ことを説明しました。</p>

<p>また各ベンチマーク結果から以下のことがわかりました。</p>

<ul>
  <li>MVC モデルにおける Model の部分が複雑で操作が多いほど Ruby 1.9 のほうが速い。
    <ul>
      <li>文字列処理が多い View の部分は Ruby 1.8 のほうが速い。</li>
    </ul>
  </li>
  <li>組み込み関数やメソッドの品揃えは重要。拡張モジュールも大変有効。
    <ul>
      <li>たとえば eRuby による HTML 生成よりも HTML エスケープ処理のほうが重いので、ここを拡張モジュールにすると効果が高い。</li>
    </ul>
  </li>
  <li>データベースを使うとそこが大きなボトルネックになるため、言語の速度は大きな問題にならない。
    <ul>
      <li>(筆者を含め) SQL が苦手なプログラマーに速度を語る資格なし。</li>
      <li>新しいアーキテクチャでデータベース周りが高速化できるといいなあ。</li>
    </ul>
  </li>
</ul>

<p>本稿ではアプリケーションのボトルネックとしてデータベースを挙げましたが、Web アプリケーションではフレームワークやライブラリも大きなボトルネックになります。
たとえば今回のベンチマークでは HTTP パラメータの解析やセッション処理などを含んでいません。
本来であればこれらも含めてベンチマークを実施することが望ましいので、機会があれば紹介したいと思います。</p>

<p>なお当然ではありますが、ベンチマーク結果は環境や使用するデータに大きく影響されます。
本稿の結果を鵜呑みにすることなく、自分の手と目で確かめるようにしてください。</p>

<p>本稿が、Ruby 1.9 への過剰な期待を薄めてくれるきっかけになることを願っています。</p>

<p>(編集：くげ)</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>これには HTTP パラメータの解析など Web アプリケーションで必要ないくつかの処理が省略されていることに注意してください。実際の Web アプリケーションではこの割合も変わります。ただし、データベースがボトルネックであることは変わらないでしょう。&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>またデータベースサーバはスケールアウトしにくいことも、大規模システムでデータベースがボトルネックになる理由のひとつです。&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>ところが世の中の認識はこれとは逆で、大規模システムほど速い言語が必要という人ばかりです。そのくせ、そういう人ほど SQL のチューニングや O/R マッパーの速度には無頓着だったりします。なんとも不思議な現象です。&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>これは MySQL のバージョンに依存する話であり、今回使用した MySQL 5.0.67 ではこのような結果になりましたが、MySQL 5.1 では blog_entries_user_id インデックスを削除しなくても select 文において PRIMARY インデックスが使われました。また MySQL 5.0.27 では逆に PRIMARY インデックスすらも使われなくなったためさらに遅くなりました。&nbsp;<a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>まさに筆者のことです。&nbsp;<a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>ただし世の中には「言語の速さ」自体が目的である場合もあるので、その場合はこの限りではありません。&nbsp;<a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

            </div>
        </div>
    </div>
  </body>
</html>
<!DOCTYPE html>
<html>
