<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ruby に型があると便利か</title>
  <meta name="description" content="はじめに">

  <script src="/js/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/css/theme.css" rel="stylesheet" type="text/css">
  <link href="/css/syntax.css" rel="stylesheet" type="text/css">

  <link rel="canonical" href="http://magazine.rubyist.net/articles/0054/0054-typestruct.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="http://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="/images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-1 hidden-xs sidebar">
                <img src="../images/rubima_logo_left_top.png" alt="Rubima Logo" class="img-responsive">

<h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="/articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="/articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="/articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="/articles/pretokyorubykaigi11/preTokyoRubyKaigi11.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="/articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="/articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="/articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="/articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="/articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="/articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="/articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="/articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="/articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="/articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="/articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="/articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="/articles/ruby200specialen/Ruby200SpecialEn.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="/articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="/articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="/articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="/articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="/articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="/articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="/articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="/articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="/articles/prerubykaigi2011/preRubyKaigi2011.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="/articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="/articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="/articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="/articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="/articles/prerubykaigi2010/preRubyKaigi2010.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="/articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="/articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="/articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="/articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="/articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="/articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="/articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="/articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="/articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="/articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="/articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="/articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="/articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="/articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="/articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="/articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="/articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="/articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="/articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="/articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="/articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="/articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="/articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="/articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="/articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="/articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="/articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="/articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="/articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="/articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="/articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-11 main">
                <img src="/images/rubima_logo_l.png">
                <h1>Ruby に型があると便利か</h1>
                <div class="social-buttons">
                    <a href="http://b.hatena.ne.jp/entry//articles/0054/0054-typestruct.html" class="hatena-bookmark-button" data-hatena-bookmark-title="Ruby に型があると便利か" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<span id="fb-root"></span>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.5";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<span class="fb-like" data-href="/articles/0054/0054-typestruct.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></span>
<a href="https://twitter.com/share" class="twitter-share-button" data-url="/articles/0054/0054-typestruct.html" data-text="Ruby に型があると便利か">ツイート</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                </div>
                <h2 id="はじめに">はじめに</h2>

<p>この記事は<a href="http://regional.rubykaigi.org/tokyo11/">東京 RubyKaigi11</a>の発表である、「Ruby に型があると便利か」<a href="https://speakerdeck.com/ksss/rubynixing-gaarutobian-li-ka">(スライド)</a><a href="https://www.youtube.com/watch?v=HwdWbJxLRdE">(動画)</a>
を元に、るびま用に書き起こしたものです。</p>

<p><a href="https://github.com/ksss/type_struct">TypeStruct</a>という gem の紹介と解説記事になります。</p>

<h2 id="typestruct-のきほん">TypeStruct のきほん</h2>

<p>TypeStruct は Ruby 組み込みの Struct のように class を作る class です</p>

<p>TypeStruct を一言で言うと「C 言語や golang の struct を Ruby で再現したもの」と言えます。実際に、TypeStruct は <a href="https://golang.org/">golang</a> と <a href="https://crystal-lang.org/">crystal-lang</a> に影響を受けています。</p>

<h3 id="インストール">インストール</h3>

<p>TypeStructはgem化しているのでrubygemsからインストールできます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> $ gem install type_struct</code></pre></figure>

<p>ruby v2.1以上をサポート対象としています。</p>

<h3 id="定義">定義</h3>

<p>TypeStruct ではデータの集まりを「型」として定義できます。</p>

<p>定義には <em>TypeStruct.new</em> を使います。</p>

<p>定義は Ruby のコードになっているので、
Ruby のコード上ならどこにでも書けます。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">NewClassName</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">key_1: </span><span class="no">Integer</span><span class="p">,</span>
  <span class="ss">key_2: </span><span class="no">String</span><span class="p">,</span>
<span class="p">)</span>

</code></pre>
</div>

<p>これで <em>NewClassName</em> という class が定義されたことになります。</p>

<p>どこか他言語を想起させる形ですね。</p>

<p>渡した Hash の key はそのままメンバー名に、value は class チェック時に使われます。</p>

<p>これが TypeStruct の型定義文になります。</p>

<p><em>NewClassName.new</em> とすることで、新たに作った型 class のインスタンスを作ることができます。</p>

<h3 id="作成代入">作成・代入</h3>

<p>インスタンス作成時には、最初に定義した class を <em>new</em> するだけです。</p>

<p>インスタンス作成後も最初の定義にそっている限り代入もできます。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="no">NewClassName</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">key_1: </span><span class="mi">123</span><span class="p">,</span>
  <span class="ss">key_2: </span><span class="s1">'hello'</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">p</span> <span class="n">foo</span> <span class="c1"># #&lt;NewClassName key_1=123, key_2="hello"&gt;</span>
<span class="nb">p</span> <span class="n">foo</span><span class="p">.</span><span class="nf">key_1</span> <span class="c1">#=&gt; 123</span>
<span class="nb">p</span> <span class="n">foo</span><span class="p">.</span><span class="nf">key_2</span> <span class="c1">#=&gt; 'hello'</span>

<span class="n">foo</span><span class="p">.</span><span class="nf">key_1</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">foo</span><span class="p">.</span><span class="nf">key_2</span> <span class="o">=</span> <span class="s1">'world'</span>
<span class="nb">p</span> <span class="n">foo</span> <span class="c1">#&lt;NewClassName key_1=0, key_2="world"&gt;</span>
<span class="nb">p</span> <span class="n">foo</span><span class="p">.</span><span class="nf">key_1</span> <span class="c1">#=&gt; 0</span>
<span class="nb">p</span> <span class="n">foo</span><span class="p">.</span><span class="nf">key_2</span> <span class="c1">#=&gt; 'world'</span>

</code></pre>
</div>

<p>型定義に沿っていれば、TypeStruct は、ただの Struct とそれほど差はありません。</p>

<p>TypeStruct はマジカルなことをするライブラリではなく、あくまでただのデータの入れ物なのです。</p>

<p>よくある注意点としては、インスタンス作成時も型定義にそっていなければならないので「インスタンス作成時は <em>nil</em> を入れておいて、</p>

<p>後で定義通りの値を入れよう」といったことが__できません__。</p>

<p>理由は、一瞬でも定義とは違う値が入ることを許してしまうと、その一瞬は定義から外れた値が入っていることになるので、定義の意味がなくなってしまうからです。</p>

<h3 id="例外">例外</h3>

<p>型定義にそっていない値でインスタンス化すると、エラーになります。</p>

<p>途中の代入でも型定義に合っていなければ同じくエラーになります。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">p</span> <span class="no">NewClassName</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">key_1: </span><span class="s1">'123'</span><span class="p">,</span>
  <span class="ss">key_2: </span><span class="s1">'hello'</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># TypeStruct::MultiTypeError:</span>
<span class="c1"># ...:in TypeError NewClassName#key_1 expect Integer got "123"</span>

<span class="n">foo</span> <span class="o">=</span> <span class="no">NewClassName</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">key_1: </span><span class="mi">123</span><span class="p">,</span>
  <span class="ss">key_2: </span><span class="s1">'hello'</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">foo</span><span class="p">.</span><span class="nf">key_1</span> <span class="o">=</span> <span class="s1">'123'</span>
<span class="c1">#=&gt; TypeError: NewClassName#key_1 expect Integer got "123"</span>

</code></pre>
</div>

<p>このエラーこそ TypeStruct の真骨頂です。</p>

<p>静的言語のような静的チェックではなく、実行時での動的チェックになりますが、想定していなかった挙動をエラーという形で検知できます。</p>

<p>誤解を恐れずに言うと「実行時にテストしているようなもの」なのです。</p>

<p>ところで、<em>TypeStruct::MultiTypeError</em> と <em>TypeError</em> が出てきました。</p>

<p>TypeError は Ruby の組み込み class ですが、名前が Type* なのであえて使っています。</p>

<p>MultiTypeError は何でしょうか。
これは、もし複数の型チェックエラーがあった場合、全ての情報を出したいという要求から生まれました。</p>

<p>MultiTypeError により、複数の型エラーがあった場合、全てのエラーを列挙してくれるので、一つなおしては実行してエラーを確認してまた一つなおす。といったストレスを緩和します。</p>

<p>TypeStruct は、ドキュメント化として読み手にもメリットがあり、デバッグのしやすさに力を入れているので書き手にもメリットがあるライブラリーなのです。</p>

<h2 id="サポート-class">サポート class</h2>

<p>TypeStruct にはその機能をサポートするための追加 class がいくつかあり、
よく使うのがこの <em>TypeStruct::ArrayOf</em> と <em>TypeStruct::Union</em> の二つの class です。</p>

<p>この二つをTypeStructと組み合わせることで、より柔軟なデータ構造が表現できます。</p>

<h3 id="arrayof">ArrayOf</h3>

<p><em>ArrayOf</em> は「〜の Array」を表すもので、<em>ArrayOf.new(String)</em> とすると、「String の Array」という型であることを TypeStruct で定義できるようになります。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Name</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">values: </span><span class="no">TypeStruct</span><span class="o">::</span><span class="no">ArrayOf</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
<span class="p">)</span>
<span class="nb">name</span> <span class="o">=</span> <span class="no">Name</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">values: </span><span class="p">[</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="s1">'baz'</span><span class="p">])</span>

<span class="nb">p</span> <span class="nb">name</span><span class="p">.</span><span class="nf">values</span>
<span class="c1">#=&gt; ["foo", "bar", "baz"]</span>

<span class="nb">name</span><span class="p">.</span><span class="nf">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">#=&gt; TypeError: Name#values expect TypeStruct::ArrayOf(String) got [1, 2, 3]</span>

</code></pre>
</div>

<p>ちなみに <em>require ‘type_struct/ext</em>’ とすると <em>ArrayOf</em> はメソッドとして定義されるようになり、<em>ArrayOf(String)</em> のように使えます。
ネームスペースを消費する副作用があるので、別途 require するようにしています。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'type_struct/ext'</span>
<span class="no">Name</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
   <span class="ss">values: </span><span class="no">ArrayOf</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
<span class="p">)</span>


</code></pre>
</div>

<h3 id="union">Union</h3>

<p>Union は「A か B のどちらかのうちの一つ」を表す型です。</p>

<p>最も使う頻度が高いのは、<em>true</em> もしくは <em>false</em> がありえるメンバーと、<em>nil</em> がありえるメンバーでしょう。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Name</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">is_show: </span><span class="no">TypeStruct</span><span class="o">::</span><span class="no">Union</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">),</span> <span class="c1"># trueもしくはfalse</span>
  <span class="ss">value: </span><span class="no">TypeStruct</span><span class="o">::</span><span class="no">Union</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">String</span><span class="p">,</span> <span class="kp">nil</span><span class="p">),</span> <span class="c1"># Stringもしくはnil</span>
<span class="p">)</span>
<span class="nb">name</span> <span class="o">=</span> <span class="no">Name</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">is_show: </span><span class="kp">true</span><span class="p">,</span>
  <span class="ss">value: </span><span class="kp">nil</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">p</span> <span class="nb">name</span><span class="p">.</span><span class="nf">value</span> <span class="o">=</span> <span class="s1">'ksss'</span> <span class="c1">#=&gt; 'ksss'</span>
<span class="nb">p</span> <span class="nb">name</span><span class="p">.</span><span class="nf">is_show</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="c1">#=&gt; TypeError: Name#is_show expect #&lt;Union true|false&gt; got nil</span>

</code></pre>
</div>

<p>このように、複数の型がありえるメンバーに有効なのが Union です。</p>

<table>
  <tbody>
    <tr>
      <td>上級者向け機能として、<em>using TypeStruct::Union::Ext</em> とすると、_Class#</td>
      <td>_ メソッドが定義され、以下の様な書き方ができるようになります。</td>
    </tr>
  </tbody>
</table>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">using</span> <span class="no">TypeStruct</span><span class="o">::</span><span class="no">Union</span><span class="o">::</span><span class="no">Ext</span>
<span class="no">Foo</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">num: </span><span class="no">Integer</span> <span class="o">|</span> <span class="kp">nil</span> <span class="c1">#=&gt; Integerもしくはnil</span>
  <span class="ss">name: </span><span class="no">Regexp</span> <span class="o">|</span> <span class="no">String</span> <span class="c1">#=&gt; RegexpもしくはString</span>
<span class="p">)</span>

</code></pre>
</div>

<p>crystal-lang のようでカッコイイですね。</p>

<h2 id="typestructfrom_hash">TypeStruct.from_hash</h2>

<p>TypeStruct をさらに強力にする機能が、この <em>from_hash</em> です。</p>

<p><em>from_hash</em> は TypeStructで作った型classから、Hash オブジェクトを元に TypeStruct のオブジェクトに変換します。そして、変換は定義にそって__再帰的__に行われます。</p>

<p>これは、Web API や設定ファイルなどの外部情報について、
TypeStruct のメリット(意味ある名前・期待した値・ドキュメント化)を享受できるようにと開発しました。</p>

<p>ここでは、from_hash の魅力をコードで紹介するため、とあるアプリケーション開発で TypeStruct を使う前と使った後で比較し丁寧に解説します。</p>

<h3 id="from_hash-の使用前">from_hash の使用前</h3>

<p>例として、Rails で組んだ Web API を実装する場合を考えます。
ユーザーが GUI 上で丸や三角などの図形を様々に配置して、配置情報をサーバーに保存する架空のアプリケーションです。</p>

<p>それぞれの図形には図形の ID ・ X,Y 座標・大きさ・回転角度などの情報を持っています。</p>

<p>これらの情報は JSON 形式でクライアントからバックエンドへと送られます。</p>

<p>送られた JSON は保存され、JSON の情報を元に一枚の画像として合成され、チーム間でシェアできる。
そんな架空アプリです。(くどい)</p>

<p>この「JSON の情報を元に、一枚の画像として合成され」の部分では JSON 文字列を Ruby で parse してループを回し、それぞれの ID から図形画像を参照して座標情報から合成する。
といったプログラムが想像できます。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">composition</span> <span class="o">=</span> <span class="no">Composition</span><span class="p">.</span><span class="nf">new</span>
<span class="n">json</span><span class="p">[</span><span class="s2">"layers"</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">layer</span><span class="o">|</span>
  <span class="n">layer</span><span class="p">[</span><span class="s2">"figures"</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">figure</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">figure</span><span class="p">[</span><span class="s2">"typo"</span><span class="p">]</span>
    <span class="k">when</span> <span class="s2">"circle"</span>
      <span class="n">circle</span> <span class="o">=</span> <span class="no">Circle</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">figure</span><span class="p">[</span><span class="s2">"circle_id"</span><span class="p">])</span>
      <span class="n">image</span> <span class="o">=</span> <span class="n">circle</span><span class="p">.</span><span class="nf">download</span>
      <span class="n">composition</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">figure</span><span class="p">[</span><span class="s2">"position"</span><span class="p">])</span>
    <span class="k">when</span> <span class="s2">"triangle"</span>
      <span class="c1"># ...</span>
    <span class="k">when</span> <span class="s2">"square"</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">composition</span><span class="p">.</span><span class="nf">to_png</span>

</code></pre>
</div>

<p>こんなプログラムで怖いのは、プログラムのtypoによるミスではないでしょうか。(実際に、上のプログラム内にはtypoが潜んでいます)</p>

<p><em>Hash#[]</em> では typo は <em>nil</em> として扱われます。
プログラミング中に、「クライアント側からの値がおかしい」のか「JSON の順番を間違えた」のかなどと考えてデバッグしている内に「ただの typo だった」というオチで時間を取られてしまったという経験はないでしょうか。
<em>Hash#[]</em> での typo は <a href="https://github.com/yuki24/did_you_mean">did_you_mean</a>でも対応できません。</p>

<p>「typo 対策なら <em>Hash#fetch</em> がある」は良い案です。
typo したら KeyError として教えてくれますし、did_you_mean も最新版では対応されています。<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>
しかしながらプログラムの見た目は <em>obj.fetch(“key”)</em> ばかりになります。
またcase 文では自動的に <em>===</em> メソッドが使われます。
それに「数字を期待していたが文字列だった」のようなケースは防げません。</p>

<h3 id="from_hash-使用後">from_hash 使用後</h3>

<p>そこでいよいよ TypeStruct の <em>from_hash</em> の出番です。</p>

<p>まず型定義を用意します。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'type_struct/ext'</span>
<span class="k">module</span> <span class="nn">Type</span>
  <span class="n">using</span> <span class="no">TypeStruct</span><span class="o">::</span><span class="no">Union</span><span class="o">::</span><span class="no">Ext</span>
  <span class="no">Position</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">x: </span><span class="no">Numeric</span><span class="p">,</span>
    <span class="ss">y: </span><span class="no">Numeric</span><span class="p">,</span>
    <span class="ss">width: </span><span class="no">Numeric</span><span class="p">,</span>
    <span class="ss">height: </span><span class="no">Numeric</span><span class="p">,</span>
    <span class="ss">rotation: </span><span class="no">Numeric</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="no">Circle</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">type: </span><span class="s2">"circle"</span><span class="p">,</span>
    <span class="ss">circle_id: </span><span class="no">Integer</span><span class="p">,</span>
    <span class="ss">position: </span><span class="no">Position</span>
  <span class="p">)</span>
  <span class="no">Triangle</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">type: </span><span class="s2">"triangle"</span><span class="p">,</span>
    <span class="ss">triangle_id: </span><span class="no">Integer</span><span class="p">,</span>
    <span class="ss">position: </span><span class="no">Position</span>
  <span class="p">)</span>
  <span class="no">Square</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">type: </span><span class="s2">"square"</span><span class="p">,</span>
    <span class="ss">square_id: </span><span class="no">Integer</span><span class="p">,</span>
    <span class="ss">position: </span><span class="no">Position</span>
  <span class="p">)</span>
  <span class="no">Layer</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">figures: </span><span class="no">ArrayOf</span><span class="p">(</span><span class="no">Circle</span> <span class="o">|</span> <span class="no">Triangle</span> <span class="o">|</span> <span class="no">Square</span><span class="p">),</span>
  <span class="p">)</span>
  <span class="no">Picture</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">layers: </span><span class="no">ArrayOf</span><span class="p">(</span><span class="no">Layer</span><span class="p">),</span>
  <span class="p">)</span>
<span class="k">end</span>

</code></pre>
</div>

<p>先ほどのプログラムを書きなおしてみます。
<em>Type::Picture.from_hash(json)</em> の部分が TypeStruct を使っている部分です</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">composition</span> <span class="o">=</span> <span class="no">Composition</span><span class="p">.</span><span class="nf">new</span>
<span class="no">Type</span><span class="o">::</span><span class="no">Picture</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="n">json</span><span class="p">).</span><span class="nf">layers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">layer</span><span class="o">|</span>
  <span class="n">layer</span><span class="p">.</span><span class="nf">figures</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">figure</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">figure</span>
    <span class="k">when</span> <span class="no">Type</span><span class="o">::</span><span class="no">Circle</span>
      <span class="n">circle</span> <span class="o">=</span> <span class="o">::</span><span class="no">Circle</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">figure</span><span class="p">.</span><span class="nf">circle_id</span><span class="p">)</span>
      <span class="n">image</span> <span class="o">=</span> <span class="n">circle</span><span class="p">.</span><span class="nf">download</span>
      <span class="n">composition</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">figure</span><span class="p">.</span><span class="nf">position</span><span class="p">)</span>
    <span class="k">when</span> <span class="no">Type</span><span class="o">::</span><span class="no">Triangle</span>
      <span class="c1"># ...</span>
    <span class="k">when</span> <span class="no">Type</span><span class="o">::</span><span class="no">Square</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">composition</span><span class="p">.</span><span class="nf">to_png</span>

</code></pre>
</div>

<p>いかがでしょうか。</p>

<ul>
  <li>typo してもすぐ気がつく(did_you_mean が効く)</li>
  <li>Class 名があるので p デバッグがやりやすい</li>
  <li>余計な文字や記号が減り、見た目がすっきりする</li>
  <li>もし JSON が想定外の形式だった場合にエラーとして検知できる</li>
  <li>case 文が文字列から class 名になったので、typo しても NameError で気付ける</li>
</ul>

<p>TypeStruct 導入によってさまざまなメリットが生まれました。</p>

<h2 id="typestruct-の利用例">TypeStruct の利用例</h2>

<p>ここでは TypeStruct が有効になる利用シーンを 3 つ上げ、具体的な導入方法を合わせて紹介します。</p>

<h3 id="json-api-のサーバー側実装">JSON API のサーバー側実装</h3>

<p>from_hash の説明と被ってしまうので要点だけ。</p>

<p>複数人開発の場合は特に、「どんな key があってどんな値がありえるのか、この key は nil になる可能性はあるのか」と言った情報が共有されているべきです。</p>

<p>そこで、TypeStruct で型情報を書いておけば正確なドキュメントにもなります。</p>

<p>しかしながら、既存のコードベースに TypeStruct を導入する場合、いちいち型を書くのが面倒になるでしょう。
この場合は自動で型コードを生成してくれるものがあると便利だろうと、TypeStruct 型定義 generator を書いてみました。</p>

<p>以下のように使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> $ echo '{"say": [{"hello": "world", "and": 4649}]}' | ruby -r type_struct/generator/json
 Say = TypeStruct.new(
   hello: String,
   and: Integer,
 )
 AutoGeneratedStruct = TypeStruct.new(
   say: ArrayOf(Say),
 )</code></pre></figure>

<p>json の部分を yaml に変えることで yaml 形式にも対応できます。</p>

<p>実際のレスポンスをドキュメントや curl の結果などから generator に渡してやれば、
自動的に TypeStruct の型コードを生成してくれます。
これをコピー&amp;ペーストするなりして使うことで型を書く手間をある程度減らせるでしょう。</p>

<h3 id="json-api-のクライアント側の実装">JSON API のクライアント側の実装</h3>

<p>JSON を受け取って処理するクライアント実装を書く場合では、
Hash の問題は存在するものの、TypeStruct を有効に使える機会は少ないでしょう。</p>

<p>理由は大抵の Web API クライアント実装を Ruby で行いたい場合は、特定のパブリックなサービスに対して行う場合が多いからです。</p>

<ul>
  <li>Web API のドキュメントが公開されていることが多い</li>
  <li>レスポンスを使った実装コードは小規模になりやすい</li>
</ul>

<p>という場合がほとんどなので、TypeStruct のドキュメントとしてのメリットが効果を持ちにくいのです。</p>

<p>しかしながら、それでも便利に使っていただける可能性を考慮し、
例としてドキュメントサービスで有名な esa.io の API ドキュメントを元に TypeStruct の型コードを書いてみました。</p>

<p><a href="https://github.com/ksss/type_struct-esa">https://github.com/ksss/type_struct-esa</a></p>

<p>このように Web API のレスポンスの TypeStruct コードを書いておけば、
レスポンスを使って整形して分解して……、などのコードが書きやすくなるでしょう。<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<h3 id="configyml">config.yml</h3>

<p>YAML で書かれたなんらかの設定ファイルを定義する場合にも、TypeStruct を活用できます。
筆者が出会った経験談としては、何段にもネストする YAML で書かれた config ファイルを、作ったはいいが YAML のインデントが一段ズレており不具合の原因になったというものでした。</p>

<p>この事故も、TypeStruct を使っていればもしかしたら防げたでしょう。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="o">---</span>
<span class="ss">foo:
  bar:
    baz:
    </span><span class="o">-</span> <span class="mi">1</span>
    <span class="o">-</span> <span class="mi">2</span>
    <span class="o">-</span> <span class="mi">3</span>
    <span class="ss">qux: </span><span class="s1">'aaa'</span> <span class="c1"># 本当は一段左にあるべき行</span>

</code></pre>
</div>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'yaml'</span>
<span class="nb">require</span> <span class="s1">'type_struct/ext'</span>
<span class="no">Bar</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">baz: </span><span class="no">ArrayOf</span><span class="p">(</span><span class="no">Integer</span><span class="p">),</span>
<span class="p">)</span>
<span class="no">Foo</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">bar: </span><span class="no">Bar</span><span class="p">,</span>
  <span class="ss">qux: </span><span class="no">String</span><span class="p">,</span>
<span class="p">)</span>
<span class="no">Root</span> <span class="o">=</span> <span class="no">TypeStruct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">foo: </span><span class="no">Foo</span><span class="p">,</span>
<span class="p">)</span>
<span class="no">Root</span><span class="p">.</span><span class="nf">from_hash</span><span class="p">(</span><span class="no">YAML</span><span class="p">.</span><span class="nf">load_file</span><span class="p">(</span><span class="s2">"config.yml"</span><span class="p">))</span>
<span class="c1">#=&gt; TypeStruct::MultiTypeError:</span>
<span class="n">t</span><span class="p">.</span><span class="nf">rb</span><span class="p">:</span><span class="mi">13</span><span class="ss">:in</span> <span class="no">TypeError</span> <span class="no">Foo</span><span class="c1">#qux expect String got nil</span>

</code></pre>
</div>

<p>既存の設定ファイルから型定義をつくる場合も、yaml の generator を使うことで作りやすくなります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> $ cat config.yml | ruby -r type_struct/generator/yaml
 AutoGeneratedStruct = TypeStruct.new(
   ...
 )</code></pre></figure>

<h2 id="おわりに">おわりに</h2>

<p>今回は<a href="https://github.com/ksss/type_struct">TypeStruct gem</a>について紹介しました。</p>

<p>「使ってるよ」とか「こうなっているともっと便利なのに」とか「ここがイケてない」など、フィードバックをいただけると大変嬉しいです。</p>

<p>TypeStructに限らず、他言語のパラダイムを覗いてみるといつものRubyプログラムが少し違って見えて楽しいですね。</p>

<h2 id="おまけ-hash-それとも-struct">おまけ Hash? それとも Struct?</h2>

<p>TypeStruct は Struct をベースに拡張した class です。
筆者は Ruby の Struct が好きなのですが、Ruby の Hash が便利すぎるために一度も使用したことがない方も多いのではないでしょうか。
そこで、どんな場合に Struct が便利でどんな場合に Hash が便利なのか、どうやって使い分ければよいのか考えてみました。</p>

<p>「TypeStruct を使うほどではないけど、Struct は便利かもなあ」と思っていただければ幸いです。</p>

<p>筆者の考えは「どんな key があるか固定なら Struct、不定なら Hash」です。</p>

<p>Struct のメリットは</p>

<ul>
  <li>class 名が付いているのでデバッグしやすい</li>
  <li>key 名を typo しても即座にわかるのでデバッグしやすい<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></li>
  <li>メンバー呼び出しの syntax が書きやすい</li>
</ul>

<p>Hash のメリットは</p>

<ul>
  <li>リテラルがあるので生成 syntax が書きやすい</li>
  <li>未知の key でも格納できる</li>
  <li>keyword argument など、言語組み込みの機能が豊富</li>
</ul>

<p>だと考えています。</p>

<p>多分に主観が含まれてはいますが、これらの以下のメリットから導き出されます。</p>

<p>(デバッグが必要になりそうなほど複雑 &amp;&amp; 寿命の長いオブジェクト &amp;&amp; key が固定)なら、Struct を使うことで、
デバッグのしやすさや、メンバー呼び出しのコードの綺麗さといったメリットを享受できます。</p>

<p>そして、(デバッグが不要なほど単純 || 寿命が短いオブジェクト || key が不定)なら、
Hash を使うことでリテラルや未知の key に対応しているといったメリットを享受できるということです。</p>

<p>だいぶ Struct の利用条件は狭そうです。
ほとんどの Rubyist は Hash の便利さはご存知だと思うので、Struct が使えるシーンのみ紹介します。</p>

<p>CLI アプリケーションのオプションを定義する場合を考えます。
CLI のオプションは、Ruby のオブジェクトにまとめてアプリケーション内で扱うことが多いでしょう。
ここで、CLI のオプションとしてどんな key がありえるのか、実装者自身は知っているはずです。
こんなときは Struct が便利です。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="no">Option</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="c1"># オプションの種類</span>
  <span class="ss">:aaa</span><span class="p">,</span>
  <span class="ss">:bbb</span><span class="p">,</span>
  <span class="ss">:ccc</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="no">Option</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="c1"># オプションのデフォルト値</span>
  <span class="kp">false</span><span class="p">,</span> <span class="c1"># aaa</span>
  <span class="mi">1</span><span class="p">,</span>     <span class="c1"># bbb</span>
  <span class="s1">'ccc'</span><span class="p">,</span> <span class="c1"># ccc</span>
<span class="p">)</span>
<span class="no">OptionParser</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">opt</span><span class="o">|</span>
  <span class="c1"># オプションの設定</span>
  <span class="n">opt</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="s2">"--aaa AAA"</span><span class="p">,</span> <span class="s2">"set aaa"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="n">o</span><span class="p">.</span><span class="nf">aaa</span> <span class="o">=</span> <span class="n">arg</span>
  <span class="k">end</span>
<span class="k">end</span><span class="p">.</span><span class="nf">parse!</span><span class="p">(</span><span class="no">ARGV</span><span class="p">)</span>

<span class="no">CLI</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

</code></pre>
</div>

<p>としておけば、どんなオプションがあるのか、デフォルト値は何か、
どのオプションに対応付けられているのかが読みやすいでしょう。
こういったオプションは複雑なロジックの中に使われたり、
コードの中での寿命が長くなりやすいので、Struct のメリットを享受しやすいでしょう。
また、Struct はオブジェクトの生成が Hash よりも高速というのもメリットでしょう。</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1">#! /usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s1">'benchmark/ips'</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"Foo.new(1,2,3)"</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Foo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"{a: 1, b: 2, c: 3}"</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">a: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">b: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">c: </span><span class="mi">3</span><span class="p">}</span>
  <span class="k">end</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">compare!</span>
<span class="k">end</span>

</code></pre>
</div>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> $ ruby t.rb
 Warming up --------------------------------------
    Foo.new(1,2,3)   231.971k i/100ms
   {a: 1, b: 2, c: 3}   129.456k i/100ms
 Calculating -------------------------------------
    Foo.new(1,2,3)      4.826M (± 5.9%) i/s -     24.125M in   5.018127s
   {a: 1, b: 2, c: 3}      2.017M (± 9.3%) i/s -      9.968M in   5.003450s

 Comparison:
    Foo.new(1,2,3):  4825587.7 i/s
   {a: 1, b: 2, c: 3}:  2017008.2 i/s - 2.39x slower</code></pre></figure>

<h2 id="著者について">著者について</h2>

<p>栗原勇樹 (<a href="https://twitter.com/_ksss_">twitter</a> <a href="https://github.com/ksss">github</a>)</p>

<p>プログラムを書くのが楽しすぎるプログラマ。<a href="http://kaja.rubyist.net/2014/kaja">RubyKaja 2014</a>(from <a href="https://asakusarb.esa.io/">asakusa.rb</a>)。<a href="http://spicelife.jp/">㈱spicelife エンジニア</a>。命より大事なものは家族。OSS開発を仕事にするのが夢。</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>提案したのオレオレ https://github.com/yuki24/did_you_mean/pull/71&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>なぜesa.ioなのかというと、筆者がよくAPIを叩いていたため。&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Struct#[]にも対応する提案したのオレオレ https://github.com/yuki24/did_you_mean/pull/73&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

            </div>
        </div>
    </div>
  </body>
</html>
<!DOCTYPE html>
<html>
